// Generated by XXML Compiler

#include <iostream>
#include <string>
#include <memory>
#include <cstdint>
#include <cstring>
#include <cstdlib>
#include <limits>
#include <cassert>
#include <stdexcept>
#include <utility>
#include <type_traits>

// ============================================
// Owned<T> - Runtime wrapper for owned values (T^)
// ============================================
namespace Language {
namespace Runtime {

template<typename T>
class Owned {
private:
    T value_;
    bool movedFrom_;

public:
    Owned() : value_(), movedFrom_(false) {}  // Default constructor
    Owned(const T& val) : value_(val), movedFrom_(false) {}  // Copy for primitives
    Owned(T&& val) : value_(std::move(val)), movedFrom_(false) {}  // Move

    // Copy constructor - enabled for primitive types only (int64_t, double, float, bool, void*)
    Owned(const Owned& other) : value_(other.value_), movedFrom_(false) {
        static_assert(
            std::is_same_v<T, int64_t> || std::is_same_v<T, double> ||
            std::is_same_v<T, float> || std::is_same_v<T, bool> ||
            std::is_same_v<T, void*> || std::is_same_v<T, const void*> ||
            std::is_same_v<T, int32_t>,
            "Owned<T> can only be copied for primitive types. "
            "For complex types, use move semantics or reference parameters.");
    }

    Owned& operator=(const Owned& other) {
        static_assert(
            std::is_same_v<T, int64_t> || std::is_same_v<T, double> ||
            std::is_same_v<T, float> || std::is_same_v<T, bool> ||
            std::is_same_v<T, void*> || std::is_same_v<T, const void*> ||
            std::is_same_v<T, int32_t>,
            "Owned<T> can only be copied for primitive types. "
            "For complex types, use move semantics or reference parameters.");
        if (this != &other) {
            value_ = other.value_;
            movedFrom_ = false;
        }
        return *this;
    }

    Owned(Owned&& other) noexcept
        : value_(std::move(other.value_)), movedFrom_(false) {
        other.movedFrom_ = true;
    }

    Owned& operator=(Owned&& other) noexcept {
        if (this != &other) {
            value_ = std::move(other.value_);
            movedFrom_ = false;
            other.movedFrom_ = true;
        }
        return *this;
    }

    T& get() {
        if (movedFrom_) {
            assert(false && "Use-after-move detected");
            throw std::runtime_error("Use-after-move detected");
        }
        return value_;
    }

    const T& get() const {
        if (movedFrom_) {
            assert(false && "Use-after-move detected");
            throw std::runtime_error("Use-after-move detected");
        }
        return value_;
    }

    T extract() {
        if (movedFrom_) {
            assert(false && "Use-after-move detected");
            throw std::runtime_error("Use-after-move detected");
        }
        movedFrom_ = true;
        return std::move(value_);
    }

    operator T&() { return get(); }
    operator const T&() const { return get(); }
    T* operator->() { return &get(); }
    const T* operator->() const { return &get(); }
    bool isMovedFrom() const { return movedFrom_; }
    
    // Equality operator - must be specialized for each type
    bool operator==(const Owned& other) const;
};

} // namespace Runtime
} // namespace Language

// Syscall intrinsic functions
class Syscall {
public:
    static void* string_create(const void* cstr) {
        return (void*)new std::string((const char*)cstr);
    }
    static const unsigned char* string_cstr(void* ptr) {
        return reinterpret_cast<const unsigned char*>(((std::string*)ptr)->c_str());
    }
    static int64_t string_length(void* ptr) {
        return ((std::string*)ptr)->length();
    }
    static void* string_concat(void* ptr1, void* ptr2) {
        std::string* s1 = (std::string*)ptr1;
        std::string* s2 = (std::string*)ptr2;
        return (void*)new std::string(*s1 + *s2);
    }
    static void* string_copy(void* ptr) {
        return (void*)new std::string(*(std::string*)ptr);
    }
    static int64_t string_equals(void* ptr1, void* ptr2) {
        return (*(std::string*)ptr1 == *(std::string*)ptr2) ? 1 : 0;
    }
    static void string_destroy(void* ptr) {
        delete (std::string*)ptr;
    }
    static void memcpy(void* dest, const void* src, size_t n) {
        std::memcpy(dest, src, n);
    }
    static const unsigned char* int_to_string(int64_t value) {
        static thread_local std::string buffer;
        buffer = std::to_string(value);
        return reinterpret_cast<const unsigned char*>(buffer.c_str());
    }
    static unsigned char* malloc(int64_t size) {
        return static_cast<unsigned char*>(std::malloc(static_cast<size_t>(size)));
    }
    static void free(void* ptr) {
        std::free(ptr);
    }
    static void* memset(void* dest, int value, int64_t size) {
        return std::memset(dest, value, static_cast<size_t>(size));
    }
    static int64_t read_int64(const void* ptr) {
        return *static_cast<const int64_t*>(ptr);
    }
    static void write_int64(void* ptr, int64_t value) {
        *static_cast<int64_t*>(ptr) = value;
    }
    static const unsigned char* string_charAt(void* strPtr, int64_t index) {
        std::string* str = static_cast<std::string*>(strPtr);
        if (index < 0 || index >= static_cast<int64_t>(str->length())) {
            static thread_local std::string empty;
            empty = "";
            return reinterpret_cast<const unsigned char*>(empty.c_str());
        }
        static thread_local std::string charBuf;
        charBuf = str->substr(static_cast<size_t>(index), 1);
        return reinterpret_cast<const unsigned char*>(charBuf.c_str());
    }
    static void* ptr_add(void* ptr, int64_t offset) {
        return static_cast<void*>(static_cast<char*>(ptr) + offset);
    }
    static unsigned char* ptr_read(const void* ptr) {
        return static_cast<unsigned char*>(*static_cast<void* const*>(ptr));
    }
    
    // Specialized overload to read as Owned<T> - returns by value
    template<typename T>
    static Language::Runtime::Owned<T> ptr_read(const void* ptr) {
        void* obj_ptr = *static_cast<void* const*>(ptr);
        if (obj_ptr == nullptr) {
            return Language::Runtime::Owned<T>(T());
        }
        T* obj = static_cast<T*>(obj_ptr);
        // Copy the object (don't transfer ownership, list still owns it)
        return Language::Runtime::Owned<T>(*obj);
    }
    static void ptr_write(void* dest, void* value) {
        *static_cast<void**>(dest) = value;
    }
    // Overload for int64_t (used for writing null pointers/terminators)
    static void ptr_write(void* dest, int64_t value) {
        *static_cast<void**>(dest) = reinterpret_cast<void*>(value);
    }
    
    // Template overloads for Owned<T> to work with List<T>
    template<typename T>
    static void ptr_write(void* dest, Language::Runtime::Owned<T> value) {
        // Allocate memory for the object and store its pointer
        T* obj = new T(std::move(value.extract()));
        *static_cast<void**>(dest) = static_cast<void*>(obj);
    }
    
    template<typename T>
    static Language::Runtime::Owned<T> ptr_read_owned(const void* ptr) {
        // Read the pointer and wrap in Owned<T> (transfers ownership)
        void* obj_ptr = *static_cast<void* const*>(ptr);
        if (obj_ptr == nullptr) {
            return Language::Runtime::Owned<T>(T());
        }
        T* obj = static_cast<T*>(obj_ptr);
        T value = std::move(*obj);
        // Note: We don't delete here because the object is still in the list
        // The list owns it until removed
        return Language::Runtime::Owned<T>(std::move(value));
    }
    
    static int64_t read_byte(const void* ptr) {
        return static_cast<int64_t>(*static_cast<const unsigned char*>(ptr));
    }
};

// System::Console intrinsic class (will be implemented after core types)
namespace System {
class Console;
} // namespace System

// Forward declarations
namespace Language::Core {
    class Bool;
    class Integer;
    class Float;
    class Double;
    class String;
}
namespace System {
    class Console;
}

// ============================================
// Core Library - Class Declarations
// ============================================

namespace Language::Core {

    class Integer {
        private:
            int64_t value;
        public:
            Integer() = default;
            Integer(int64_t val) : value(val) {}
            static Integer Constructor(int64_t val) { return Integer(val); }
            int64_t toInt64() const;
            Language::Runtime::Owned<Language::Core::Integer> add(const Language::Core::Integer& other) const;
            Language::Runtime::Owned<Language::Core::Integer> subtract(const Language::Core::Integer& other) const;
            Language::Runtime::Owned<Language::Core::Integer> multiply(const Language::Core::Integer& other) const;
            Language::Runtime::Owned<Language::Core::Integer> divide(const Language::Core::Integer& other) const;
            Language::Runtime::Owned<Language::Core::Integer> modulo(const Language::Core::Integer& other) const;
            Language::Runtime::Owned<Language::Core::Bool> equals(const Language::Core::Integer& other) const;
            Language::Runtime::Owned<Language::Core::Bool> lessThan(const Language::Core::Integer& other) const;
            Language::Runtime::Owned<Language::Core::Bool> greaterThan(const Language::Core::Integer& other) const;
            Language::Runtime::Owned<Language::Core::Bool> lessOrEqual(const Language::Core::Integer& other) const;
            Language::Runtime::Owned<Language::Core::Bool> greaterOrEqual(const Language::Core::Integer& other) const;
            Language::Runtime::Owned<Language::Core::Integer> negate() const;
            Language::Runtime::Owned<Language::Core::Integer> abs() const;
            Language::Runtime::Owned<Language::Core::String> toString() const;
    };
    
} // namespace Language::Core

namespace Language::Core {

    class Bool {
        private:
            bool value;
        public:
            Bool() = default;
            Bool(bool val) : value(val) {}
            static Bool Constructor(bool val) { return Bool(val); }
            bool toBool() const;
            Language::Runtime::Owned<Language::Core::Bool> and_(const Language::Core::Bool& other) const;
            Language::Runtime::Owned<Language::Core::Bool> or_(const Language::Core::Bool& other) const;
            Language::Runtime::Owned<Language::Core::Bool> not_() const;
            Language::Runtime::Owned<Language::Core::Bool> xor_(const Language::Core::Bool& other) const;
            Language::Runtime::Owned<Language::Core::Bool> equals(const Language::Core::Bool& other) const;
            Language::Runtime::Owned<Language::Core::Integer> toInteger() const;
    };
    
} // namespace Language::Core

namespace Language::Core {

    class Float {
        private:
            float value;
        public:
            Float() = default;
            Float(float val) : value(val) {}
            static Float Constructor(float val) { return Float(val); }
            float toFloat() const;
            Language::Runtime::Owned<Language::Core::Float> add(const Language::Core::Float& other) const;
            Language::Runtime::Owned<Language::Core::Float> subtract(const Language::Core::Float& other) const;
            Language::Runtime::Owned<Language::Core::Float> multiply(const Language::Core::Float& other) const;
            Language::Runtime::Owned<Language::Core::Float> divide(const Language::Core::Float& other) const;
            Language::Runtime::Owned<Language::Core::Bool> equals(const Language::Core::Float& other) const;
            Language::Runtime::Owned<Language::Core::Bool> lessThan(const Language::Core::Float& other) const;
            Language::Runtime::Owned<Language::Core::Bool> greaterThan(const Language::Core::Float& other) const;
            Language::Runtime::Owned<Language::Core::Float> negate() const;
            Language::Runtime::Owned<Language::Core::Float> abs() const;
            Language::Runtime::Owned<Language::Core::Integer> toInteger() const;
            Language::Core::Double toDouble() const;
    };
    
} // namespace Language::Core

namespace Language::Core {

    class Double {
        private:
            double value;
        public:
            Double() = default;
            Double(double val) : value(val) {}
            static Double Constructor(double val) { return Double(val); }
            double toDouble() const;
            Language::Runtime::Owned<Language::Core::Double> add(const Language::Core::Double& other) const;
            Language::Runtime::Owned<Language::Core::Double> subtract(const Language::Core::Double& other) const;
            Language::Runtime::Owned<Language::Core::Double> multiply(const Language::Core::Double& other) const;
            Language::Runtime::Owned<Language::Core::Double> divide(const Language::Core::Double& other) const;
            Language::Runtime::Owned<Language::Core::Bool> equals(const Language::Core::Double& other) const;
            Language::Runtime::Owned<Language::Core::Bool> lessThan(const Language::Core::Double& other) const;
            Language::Runtime::Owned<Language::Core::Bool> greaterThan(const Language::Core::Double& other) const;
            Language::Runtime::Owned<Language::Core::Bool> lessOrEqual(const Language::Core::Double& other) const;
            Language::Runtime::Owned<Language::Core::Bool> greaterOrEqual(const Language::Core::Double& other) const;
            Language::Runtime::Owned<Language::Core::Double> negate() const;
            Language::Runtime::Owned<Language::Core::Double> abs() const;
            Language::Runtime::Owned<Language::Core::Integer> toInteger() const;
            Language::Core::Float toFloat() const;
    };
    
} // namespace Language::Core

namespace Language::Core {

    class String {
        private:
            void* data;
        public:
            String() = default;
            String(const void* cstr) {
                void* ptr = Syscall::string_create(cstr);
                Syscall::memcpy(&data, &ptr, 8);
            }
            static String Constructor(const void* cstr) { return String(cstr); }
            const unsigned char* toCString() const;
            Language::Runtime::Owned<Language::Core::Integer> length() const;
            Language::Runtime::Owned<Language::Core::Bool> isEmpty() const;
            Language::Runtime::Owned<Language::Core::String> append(const Language::Core::String& other);
            Language::Runtime::Owned<Language::Core::String> copy() const;
            Language::Runtime::Owned<Language::Core::Bool> equals(const Language::Core::String& other) const;
            static Language::Runtime::Owned<Language::Core::String> FromCString(unsigned char* ptr);
            Language::Runtime::Owned<Language::Core::String> charAt(const Language::Core::Integer& index) const;
            void dispose();
    };
    
} // namespace Language::Core

// ============================================
// Core Library - Method Implementations
// ============================================

namespace Language::Core {

        int64_t Language::Core::Integer::toInt64() const {
        return value;
    }
    Language::Runtime::Owned<Language::Core::Integer> Language::Core::Integer::add(const Language::Core::Integer& other) const {
        int64_t v1 = value;
        int64_t v2 = other.value;
        int64_t result = v1 + v2;
        return Language::Core::Integer(result);
    }
    Language::Runtime::Owned<Language::Core::Integer> Language::Core::Integer::subtract(const Language::Core::Integer& other) const {
        int64_t v1 = value;
        int64_t v2 = other.value;
        int64_t result = v1 - v2;
        return Language::Core::Integer(result);
    }
    Language::Runtime::Owned<Language::Core::Integer> Language::Core::Integer::multiply(const Language::Core::Integer& other) const {
        int64_t v1 = value;
        int64_t v2 = other.value;
        int64_t result = v1 * v2;
        return Language::Core::Integer(result);
    }
    Language::Runtime::Owned<Language::Core::Integer> Language::Core::Integer::divide(const Language::Core::Integer& other) const {
        int64_t v1 = value;
        int64_t v2 = other.value;
        int64_t result = v1 / v2;
        return Language::Core::Integer(result);
    }
    Language::Runtime::Owned<Language::Core::Integer> Language::Core::Integer::modulo(const Language::Core::Integer& other) const {
        int64_t v1 = value;
        int64_t v2 = other.value;
        int64_t result = v1 % v2;
        return Language::Core::Integer(result);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Integer::equals(const Language::Core::Integer& other) const {
        int64_t v1 = value;
        int64_t v2 = other.value;
        if (v1 == v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Integer::lessThan(const Language::Core::Integer& other) const {
        int64_t v1 = value;
        int64_t v2 = other.value;
        if (v1 < v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Integer::greaterThan(const Language::Core::Integer& other) const {
        int64_t v1 = value;
        int64_t v2 = other.value;
        if (v1 > v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Integer::lessOrEqual(const Language::Core::Integer& other) const {
        int64_t v1 = value;
        int64_t v2 = other.value;
        if (v1 <= v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Integer::greaterOrEqual(const Language::Core::Integer& other) const {
        int64_t v1 = value;
        int64_t v2 = other.value;
        if (v1 >= v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Integer> Language::Core::Integer::negate() const {
        int64_t v = value;
        int64_t result = 0 - v;
        return Language::Core::Integer(result);
    }
    Language::Runtime::Owned<Language::Core::Integer> Language::Core::Integer::abs() const {
        int64_t v = value;
        if (v < 0) {
            int64_t result = 0 - v;
            return Language::Core::Integer(result);
        }
        return Language::Core::Integer(v);
    }
    Language::Runtime::Owned<Language::Core::String> Language::Core::Integer::toString() const {
        int64_t v = value;
        const unsigned char* str = Syscall::int_to_string(v);
        return Language::Core::String(str);
    }
} // namespace Language::Core

namespace Language::Core {

        bool Language::Core::Bool::toBool() const {
        return value;
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Bool::and_(const Language::Core::Bool& other) const {
        bool v1 = value;
        bool v2 = other.value;
        bool result = v1 && v2;
        return Language::Core::Bool(result);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Bool::or_(const Language::Core::Bool& other) const {
        bool v1 = value;
        bool v2 = other.value;
        bool result = v1 || v2;
        return Language::Core::Bool(result);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Bool::not_() const {
        bool v = value;
        bool result = !v;
        return Language::Core::Bool(result);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Bool::xor_(const Language::Core::Bool& other) const {
        bool v1 = value;
        bool v2 = other.value;
        if (v1 == v2) {
            return Language::Core::Bool(false);
        }
        return Language::Core::Bool(true);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Bool::equals(const Language::Core::Bool& other) const {
        bool v1 = value;
        bool v2 = other.value;
        if (v1 == v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Integer> Language::Core::Bool::toInteger() const {
        bool v = value;
        if (v == true) {
            return Language::Core::Integer(1);
        }
        return Language::Core::Integer(0);
    }
} // namespace Language::Core

namespace Language::Core {

        float Language::Core::Float::toFloat() const {
        return value;
    }
    Language::Runtime::Owned<Language::Core::Float> Language::Core::Float::add(const Language::Core::Float& other) const {
        float v1 = value;
        float v2 = other.value;
        float result = v1 + v2;
        return Language::Core::Float(result);
    }
    Language::Runtime::Owned<Language::Core::Float> Language::Core::Float::subtract(const Language::Core::Float& other) const {
        float v1 = value;
        float v2 = other.value;
        float result = v1 - v2;
        return Language::Core::Float(result);
    }
    Language::Runtime::Owned<Language::Core::Float> Language::Core::Float::multiply(const Language::Core::Float& other) const {
        float v1 = value;
        float v2 = other.value;
        float result = v1 * v2;
        return Language::Core::Float(result);
    }
    Language::Runtime::Owned<Language::Core::Float> Language::Core::Float::divide(const Language::Core::Float& other) const {
        float v1 = value;
        float v2 = other.value;
        float result = v1 / v2;
        return Language::Core::Float(result);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Float::equals(const Language::Core::Float& other) const {
        float v1 = value;
        float v2 = other.value;
        if (v1 == v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Float::lessThan(const Language::Core::Float& other) const {
        float v1 = value;
        float v2 = other.value;
        if (v1 < v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Float::greaterThan(const Language::Core::Float& other) const {
        float v1 = value;
        float v2 = other.value;
        if (v1 > v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Float> Language::Core::Float::negate() const {
        float v = value;
        float zero = 0;
        float result = zero - v;
        return Language::Core::Float(result);
    }
    Language::Runtime::Owned<Language::Core::Float> Language::Core::Float::abs() const {
        float v = value;
        float zero = 0;
        if (v < zero) {
            float result = zero - v;
            return Language::Core::Float(result);
        }
        return Language::Core::Float(v);
    }
    Language::Runtime::Owned<Language::Core::Integer> Language::Core::Float::toInteger() const {
        float v = value;
        int64_t result = v;
        return Language::Core::Integer(result);
    }
    Language::Core::Double Language::Core::Float::toDouble() const {
        float v = value;
        double result = v;
        return Language::Core::Double(result);
    }
} // namespace Language::Core

namespace Language::Core {

        double Language::Core::Double::toDouble() const {
        return value;
    }
    Language::Runtime::Owned<Language::Core::Double> Language::Core::Double::add(const Language::Core::Double& other) const {
        double v1 = value;
        double v2 = other.value;
        double result = v1 + v2;
        return Language::Core::Double(result);
    }
    Language::Runtime::Owned<Language::Core::Double> Language::Core::Double::subtract(const Language::Core::Double& other) const {
        double v1 = value;
        double v2 = other.value;
        double result = v1 - v2;
        return Language::Core::Double(result);
    }
    Language::Runtime::Owned<Language::Core::Double> Language::Core::Double::multiply(const Language::Core::Double& other) const {
        double v1 = value;
        double v2 = other.value;
        double result = v1 * v2;
        return Language::Core::Double(result);
    }
    Language::Runtime::Owned<Language::Core::Double> Language::Core::Double::divide(const Language::Core::Double& other) const {
        double v1 = value;
        double v2 = other.value;
        double result = v1 / v2;
        return Language::Core::Double(result);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Double::equals(const Language::Core::Double& other) const {
        double v1 = value;
        double v2 = other.value;
        if (v1 == v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Double::lessThan(const Language::Core::Double& other) const {
        double v1 = value;
        double v2 = other.value;
        if (v1 < v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Double::greaterThan(const Language::Core::Double& other) const {
        double v1 = value;
        double v2 = other.value;
        if (v1 > v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Double::lessOrEqual(const Language::Core::Double& other) const {
        double v1 = value;
        double v2 = other.value;
        if (v1 <= v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Double::greaterOrEqual(const Language::Core::Double& other) const {
        double v1 = value;
        double v2 = other.value;
        if (v1 >= v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Double> Language::Core::Double::negate() const {
        double v = value;
        double zero = 0;
        double result = zero - v;
        return Language::Core::Double(result);
    }
    Language::Runtime::Owned<Language::Core::Double> Language::Core::Double::abs() const {
        double v = value;
        double zero = 0;
        if (v < zero) {
            double result = zero - v;
            return Language::Core::Double(result);
        }
        return Language::Core::Double(v);
    }
    Language::Runtime::Owned<Language::Core::Integer> Language::Core::Double::toInteger() const {
        double v = value;
        int64_t result = v;
        return Language::Core::Integer(result);
    }
    Language::Core::Float Language::Core::Double::toFloat() const {
        double v = value;
        float result = v;
        return Language::Core::Float(result);
    }
} // namespace Language::Core

namespace Language::Core {

        const unsigned char* Language::Core::String::toCString() const {
        void* ptr = data;
        return Syscall::string_cstr(ptr);
    }
    Language::Runtime::Owned<Language::Core::Integer> Language::Core::String::length() const {
        void* ptr = data;
        int64_t len = Syscall::string_length(ptr);
        return Language::Core::Integer(len);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::String::isEmpty() const {
        void* ptr = data;
        int64_t len = Syscall::string_length(ptr);
        if (len == 0) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::String> Language::Core::String::append(const Language::Core::String& other) {
        void* ptr1 = data;
        void* ptr2 = other.data;
        void* newPtr = Syscall::string_concat(ptr1, ptr2);
        Syscall::memcpy(&data, &newPtr, 8);
        return std::move(*this);
    }
    Language::Runtime::Owned<Language::Core::String> Language::Core::String::copy() const {
        const unsigned char* empty = reinterpret_cast<const unsigned char*>("");
        Language::Runtime::Owned<Language::Core::String> result = Language::Core::String(empty);
        void* ptr = data;
        void* newPtr = Syscall::string_copy(ptr);
        Syscall::memcpy(&result->data, &newPtr, 8);
        return std::move(result);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::String::equals(const Language::Core::String& other) const {
        void* ptr1 = data;
        void* ptr2 = other.data;
        int64_t result = Syscall::string_equals(ptr1, ptr2);
        if (result == 1) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::String> Language::Core::String::FromCString(unsigned char* ptr) {
        void* strPtr = Syscall::string_create(ptr);
        Language::Runtime::Owned<Language::Core::String> result = Language::Core::String(reinterpret_cast<const unsigned char*>(""));
        Syscall::memcpy(&result->data, &strPtr, 8);
        return std::move(result);
    }
    Language::Runtime::Owned<Language::Core::String> Language::Core::String::charAt(const Language::Core::Integer& index) const {
        void* ptr = data;
        int64_t idx = index.toInt64();
        const unsigned char* charCStr = Syscall::string_charAt(ptr, idx);
        return Language::Core::String(charCStr);
    }
    void Language::Core::String::dispose() {
        void* ptr = data;
        if (ptr != 0) {
            Syscall::string_destroy(ptr);
            void* zero = 0;
            Syscall::memcpy(&data, &zero, 8);
        }
    }
} // namespace Language::Core


// Equality operator specialization for Owned<String>
// String uses equals() method instead of operator==
namespace Language {
namespace Runtime {
template<>
inline bool Owned<Language::Core::String>::operator==(const Owned<Language::Core::String>& other) const {
    Language::Core::String& lhs = const_cast<Language::Core::String&>(this->get());
    Language::Core::String& rhs = const_cast<Language::Core::String&>(other.get());
    return lhs.equals(rhs)->toBool();
}
} // namespace Runtime
} // namespace Language

// ============================================
// System::Console Implementation (C++ intrinsic)
// ============================================
namespace System {
class Console {
public:
    // Print without newline - takes Owned<String> by rvalue reference
    static void print(Language::Runtime::Owned<Language::Core::String>&& str) {
        const char* cstr = (const char*)str.get().toCString();
        std::cout << cstr;
        std::cout.flush();
    }

    // Print with newline - takes Owned<String> by rvalue reference
    static void printLine(Language::Runtime::Owned<Language::Core::String>&& str) {
        const char* cstr = (const char*)str.get().toCString();
        std::cout << cstr << std::endl;
    }

    // Read a line from stdin - returns wrapped String
    static Language::Runtime::Owned<Language::Core::String> readLine() {
        std::string* line = new std::string();
        std::getline(std::cin, *line);
        return Language::Core::String((void*)line);
    }

    // Read a single character - returns wrapped String
    static Language::Runtime::Owned<Language::Core::String> readChar() {
        std::string* ch = new std::string();
        char c;
        if (std::cin.get(c)) {
            *ch = c;
        }
        return Language::Core::String((void*)ch);
    }

    // Read an integer - returns wrapped Integer
    static Language::Runtime::Owned<Language::Core::Integer> readInt() {
        int64_t value = 0;
        std::cin >> value;
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        return Language::Core::Integer(value);
    }

    // Read a float - returns wrapped Float
    static Language::Runtime::Owned<Language::Core::Float> readFloat() {
        float value = 0.0f;
        std::cin >> value;
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        return Language::Core::Float(value);
    }

    // Read a double - returns wrapped Double
    static Language::Runtime::Owned<Language::Core::Double> readDouble() {
        double value = 0.0;
        std::cin >> value;
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        return Language::Core::Double(value);
    }

    // Read a boolean - reads 'true'/'false' or '1'/'0', returns wrapped Bool
    static Language::Runtime::Owned<Language::Core::Bool> readBool() {
        std::string input;
        std::cin >> input;
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        // Convert to lowercase for comparison
        for (auto& c : input) c = std::tolower(c);
        bool result = (input == "true" || input == "1" || input == "yes");
        return Language::Core::Bool(result);
    }
};
} // namespace System

// ============================================
// Language::Core::Mem Implementation
// ============================================
namespace Language {
namespace Core {
namespace Mem {

    // Move operation - transfers ownership from Owned<T>
    template<typename T>
    Language::Runtime::Owned<T> move(Language::Runtime::Owned<T>& owned) {
        T extracted = owned.extract();
        return Language::Runtime::Owned<T>(std::move(extracted));
    }

} // namespace Mem
} // namespace Core
} // namespace Language

// ============================================
// Module: Language/Collections/Array.XXML
// ============================================
namespace Collections {

} // namespace Collections



// ============================================
// Module: Language/Collections/HashMap.XXML
// ============================================
namespace Collections {

    class HashMap {
        private:
            unsigned char* bucketsPtr;
            int64_t capacity;
            int64_t count;
        public:
            HashMap() = default;
            void init() {
                int64_t initialCap = 16;
                int64_t size = initialCap * 8;
                unsigned char* ptr = Syscall::malloc(size);
                Syscall::memset(ptr, 0, size);
                Syscall::memcpy(&bucketsPtr, &ptr, 8);
                Syscall::memcpy(&capacity, &initialCap, 8);
                int64_t zero = 0;
                Syscall::memcpy(&count, &zero, 8);
            }
            void put(Language::Runtime::Owned<Language::Core::String> key, Language::Runtime::Owned<Language::Core::String> value) {
                int64_t currentCap = capacity;
                int64_t hashVal = hashString(std::move(key));
                int64_t bucketIndex = hashVal % currentCap;
                unsigned char* currentBucketsPtr = bucketsPtr;
                int64_t offset = bucketIndex * 8;
                unsigned char* bucketPos = currentBucketsPtr + offset;
                unsigned char* headPtr = Syscall::ptr_read(bucketPos);
                if (headPtr == 0) {
                    createNode(bucketPos, std::move(key), std::move(value));
                    int64_t currentCount = count;
                    int64_t newCount = currentCount + 1;
                    Syscall::memcpy(&count, &newCount, 8);
                } else {
                    putInChain(headPtr, bucketPos, std::move(key), std::move(value));
                }
            }
            Language::Runtime::Owned<Language::Core::String> get(Language::Runtime::Owned<Language::Core::String> key) {
                int64_t currentCap = capacity;
                int64_t hashVal = hashString(std::move(key));
                int64_t bucketIndex = hashVal % currentCap;
                unsigned char* currentBucketsPtr = bucketsPtr;
                int64_t offset = bucketIndex * 8;
                unsigned char* bucketPos = currentBucketsPtr + offset;
                unsigned char* headPtr = Syscall::ptr_read(bucketPos);
                if (headPtr == 0) {
                    return Language::Core::String(reinterpret_cast<const unsigned char*>(""));
                } else {
                    return findValueInChain(headPtr, std::move(key));
                }
            }
            Language::Runtime::Owned<Language::Core::Bool> containsKey(Language::Runtime::Owned<Language::Core::String> key) {
                Language::Runtime::Owned<Language::Core::String> result = get(std::move(key));
                Language::Runtime::Owned<Language::Core::Integer> lenInt = result.get().length();
                int64_t len = lenInt.get().toInt64();
                if (len == 0) {
                    return Language::Core::Bool(false);
                } else {
                    return Language::Core::Bool(true);
                }
            }
            Language::Runtime::Owned<Language::Core::Integer> size() {
                int64_t currentCount = count;
                return Language::Core::Integer(currentCount);
            }
            Language::Runtime::Owned<Language::Core::Bool> isEmpty() {
                int64_t currentCount = count;
                if (currentCount == 0) {
                    return Language::Core::Bool(true);
                } else {
                    return Language::Core::Bool(false);
                }
            }
            void print() {
                System::Console::printLine(Language::Core::String(reinterpret_cast<const unsigned char*>("{")));
                printBuckets(Language::Core::Integer(0));
                System::Console::printLine(Language::Core::String(reinterpret_cast<const unsigned char*>("}")));
            }
            void dispose() {
                disposeBuckets(Language::Core::Integer(0));
                unsigned char* currentBucketsPtr = bucketsPtr;
                if (currentBucketsPtr != 0) {
                    Syscall::free(currentBucketsPtr);
                    unsigned char* zero = 0;
                    Syscall::memcpy(&bucketsPtr, &zero, 8);
                }
            }
        private:
            int64_t hashString(Language::Runtime::Owned<Language::Core::String> str) {
                Language::Runtime::Owned<Language::Core::Integer> lenInt = str.get().length();
                int64_t len = lenInt.get().toInt64();
                return hashHelper(std::move(str), Language::Core::Integer(0), Language::Core::Integer(5381), Language::Core::Integer(len));
            }
            int64_t hashHelper(Language::Runtime::Owned<Language::Core::String> str, const Language::Core::Integer& index, Language::Runtime::Owned<Language::Core::Integer> hash, Language::Runtime::Owned<Language::Core::Integer> len) {
                int64_t idx = index.toInt64();
                int64_t length = len.get().toInt64();
                if (idx >= length) {
                    int64_t result = hash.get().toInt64();
                    if (result < 0) {
                        int64_t negOne = 0 - 1;
                        return result * negOne;
                    } else {
                        return std::move(result);
                    }
                }
                Language::Runtime::Owned<Language::Core::String> charStr = str.get().charAt(index);
                unsigned char* charCStr = const_cast<unsigned char*>(charStr.get().toCString());
                int64_t charVal = Syscall::read_byte(charCStr);
                int64_t currentHash = hash.get().toInt64();
                int64_t newHash = currentHash * 33 + charVal;
                Language::Runtime::Owned<Language::Core::Integer> nextIndex = index.add(Language::Core::Integer(1));
                return hashHelper(std::move(str), std::move(nextIndex), Language::Core::Integer(newHash), std::move(len));
            }
            void createNode(unsigned char* bucketPos, Language::Runtime::Owned<Language::Core::String> key, Language::Runtime::Owned<Language::Core::String> value) {
                int64_t nodeSize = 24;
                unsigned char* nodePtr = Syscall::malloc(nodeSize);
                Language::Runtime::Owned<Language::Core::Integer> keyLenInt = key.get().length();
                int64_t keyLen = keyLenInt.get().toInt64();
                int64_t keyAllocSize = keyLen + 1;
                unsigned char* keyCopy = Syscall::malloc(keyAllocSize);
                unsigned char* keySrc = const_cast<unsigned char*>(key.get().toCString());
                Syscall::memcpy(keyCopy, keySrc, keyLen);
                unsigned char* keyNullPos = keyCopy + keyLen;
                int64_t zero = 0;
                Syscall::ptr_write(keyNullPos, zero);
                Language::Runtime::Owned<Language::Core::Integer> valueLenInt = value.get().length();
                int64_t valueLen = valueLenInt.get().toInt64();
                int64_t valueAllocSize = valueLen + 1;
                unsigned char* valueCopy = Syscall::malloc(valueAllocSize);
                unsigned char* valueSrc = const_cast<unsigned char*>(value.get().toCString());
                Syscall::memcpy(valueCopy, valueSrc, valueLen);
                unsigned char* valueNullPos = valueCopy + valueLen;
                Syscall::ptr_write(valueNullPos, zero);
                Syscall::ptr_write(nodePtr, keyCopy);
                unsigned char* valuePos = nodePtr + 8;
                Syscall::ptr_write(valuePos, valueCopy);
                unsigned char* nextPos = nodePtr + 16;
                Syscall::ptr_write(nextPos, zero);
                Syscall::ptr_write(bucketPos, nodePtr);
            }
            void putInChain(unsigned char* nodePtr, unsigned char* bucketPos, Language::Runtime::Owned<Language::Core::String> key, Language::Runtime::Owned<Language::Core::String> value) {
                unsigned char* keyPtr = Syscall::ptr_read(nodePtr);
                Language::Runtime::Owned<Language::Core::String> nodeKey = Language::Core::String::FromCString(keyPtr);
                if (nodeKey == key) {
                    unsigned char* valuePos = nodePtr + 8;
                    unsigned char* oldValuePtr = Syscall::ptr_read(valuePos);
                    Syscall::free(oldValuePtr);
                    Language::Runtime::Owned<Language::Core::Integer> valueLenInt = value.get().length();
                    int64_t valueLen = valueLenInt.get().toInt64();
                    int64_t valueAllocSize = valueLen + 1;
                    unsigned char* valueCopy = Syscall::malloc(valueAllocSize);
                    unsigned char* valueSrc = const_cast<unsigned char*>(value.get().toCString());
                    Syscall::memcpy(valueCopy, valueSrc, valueLen);
                    unsigned char* valueNullPos = valueCopy + valueLen;
                    int64_t zero = 0;
                    Syscall::ptr_write(valueNullPos, zero);
                    Syscall::ptr_write(valuePos, valueCopy);
                } else {
                    unsigned char* nextPos = nodePtr + 16;
                    unsigned char* nextPtr = Syscall::ptr_read(nextPos);
                    if (nextPtr == 0) {
                        createNodeInChain(nextPos, std::move(key), std::move(value));
                        int64_t currentCount = count;
                        int64_t newCount = currentCount + 1;
                        Syscall::memcpy(&count, &newCount, 8);
                    } else {
                        putInChain(nextPtr, bucketPos, std::move(key), std::move(value));
                    }
                }
            }
            void createNodeInChain(unsigned char* nextPos, Language::Runtime::Owned<Language::Core::String> key, Language::Runtime::Owned<Language::Core::String> value) {
                int64_t nodeSize = 24;
                unsigned char* nodePtr = Syscall::malloc(nodeSize);
                Language::Runtime::Owned<Language::Core::Integer> keyLenInt = key.get().length();
                int64_t keyLen = keyLenInt.get().toInt64();
                int64_t keyAllocSize = keyLen + 1;
                unsigned char* keyCopy = Syscall::malloc(keyAllocSize);
                unsigned char* keySrc = const_cast<unsigned char*>(key.get().toCString());
                Syscall::memcpy(keyCopy, keySrc, keyLen);
                unsigned char* keyNullPos = keyCopy + keyLen;
                int64_t zero = 0;
                Syscall::ptr_write(keyNullPos, zero);
                Language::Runtime::Owned<Language::Core::Integer> valueLenInt = value.get().length();
                int64_t valueLen = valueLenInt.get().toInt64();
                int64_t valueAllocSize = valueLen + 1;
                unsigned char* valueCopy = Syscall::malloc(valueAllocSize);
                unsigned char* valueSrc = const_cast<unsigned char*>(value.get().toCString());
                Syscall::memcpy(valueCopy, valueSrc, valueLen);
                unsigned char* valueNullPos = valueCopy + valueLen;
                Syscall::ptr_write(valueNullPos, zero);
                Syscall::ptr_write(nodePtr, keyCopy);
                unsigned char* valuePos = nodePtr + 8;
                Syscall::ptr_write(valuePos, valueCopy);
                unsigned char* nextPtrPos = nodePtr + 16;
                Syscall::ptr_write(nextPtrPos, zero);
                Syscall::ptr_write(nextPos, nodePtr);
            }
            Language::Runtime::Owned<Language::Core::String> findValueInChain(unsigned char* nodePtr, Language::Runtime::Owned<Language::Core::String> key) {
                unsigned char* keyPtr = Syscall::ptr_read(nodePtr);
                Language::Runtime::Owned<Language::Core::String> nodeKey = Language::Core::String::FromCString(keyPtr);
                if (nodeKey == key) {
                    unsigned char* valuePos = nodePtr + 8;
                    unsigned char* valuePtr = Syscall::ptr_read(valuePos);
                    return Language::Core::String::FromCString(valuePtr);
                } else {
                    unsigned char* nextPos = nodePtr + 16;
                    unsigned char* nextPtr = Syscall::ptr_read(nextPos);
                    if (nextPtr == 0) {
                        return Language::Core::String(reinterpret_cast<const unsigned char*>(""));
                    } else {
                        return findValueInChain(nextPtr, std::move(key));
                    }
                }
            }
            void disposeChain(unsigned char* nodePtr) {
                if (nodePtr == 0) {
                    return;
                }
                unsigned char* nextPos = nodePtr + 16;
                unsigned char* nextPtr = Syscall::ptr_read(nextPos);
                unsigned char* keyPtr = Syscall::ptr_read(nodePtr);
                if (keyPtr != 0) {
                    Syscall::free(keyPtr);
                }
                unsigned char* valuePos = nodePtr + 8;
                unsigned char* valuePtr = Syscall::ptr_read(valuePos);
                if (valuePtr != 0) {
                    Syscall::free(valuePtr);
                }
                Syscall::free(nodePtr);
                disposeChain(nextPtr);
            }
            void disposeBuckets(const Language::Core::Integer& index) {
                int64_t currentCap = capacity;
                int64_t idx = index.toInt64();
                if (idx >= currentCap) {
                    return;
                }
                unsigned char* currentBucketsPtr = bucketsPtr;
                int64_t offset = idx * 8;
                unsigned char* bucketPos = currentBucketsPtr + offset;
                unsigned char* headPtr = Syscall::ptr_read(bucketPos);
                if (headPtr != 0) {
                    disposeChain(headPtr);
                }
                Language::Runtime::Owned<Language::Core::Integer> nextIndex = index.add(Language::Core::Integer(1));
                disposeBuckets(std::move(nextIndex));
            }
            void printChain(unsigned char* nodePtr) {
                if (nodePtr == 0) {
                    return;
                }
                unsigned char* keyPtr = Syscall::ptr_read(nodePtr);
                Language::Runtime::Owned<Language::Core::String> nodeKey = Language::Core::String::FromCString(keyPtr);
                unsigned char* valuePos = nodePtr + 8;
                unsigned char* valuePtr = Syscall::ptr_read(valuePos);
                Language::Runtime::Owned<Language::Core::String> nodeValue = Language::Core::String::FromCString(valuePtr);
                System::Console::print(Language::Core::String(reinterpret_cast<const unsigned char*>("  \"")));
                System::Console::print(std::move(nodeKey));
                System::Console::print(Language::Core::String(reinterpret_cast<const unsigned char*>("\": \"")));
                System::Console::print(std::move(nodeValue));
                System::Console::printLine(Language::Core::String(reinterpret_cast<const unsigned char*>("\"")));
                unsigned char* nextPos = nodePtr + 16;
                unsigned char* nextPtr = Syscall::ptr_read(nextPos);
                printChain(nextPtr);
            }
            void printBuckets(const Language::Core::Integer& index) {
                int64_t currentCap = capacity;
                int64_t idx = index.toInt64();
                if (idx >= currentCap) {
                    return;
                }
                unsigned char* currentBucketsPtr = bucketsPtr;
                int64_t offset = idx * 8;
                unsigned char* bucketPos = currentBucketsPtr + offset;
                unsigned char* headPtr = Syscall::ptr_read(bucketPos);
                if (headPtr != 0) {
                    printChain(headPtr);
                }
                Language::Runtime::Owned<Language::Core::Integer> nextIndex = index.add(Language::Core::Integer(1));
                printBuckets(std::move(nextIndex));
            }
    };
    
} // namespace Collections



// ============================================
// Module: Language/Collections/List.XXML
// ============================================
namespace Collections {

} // namespace Collections



// ============================================
// Module: Language/Core/None.XXML
// ============================================
namespace Language::Core {

    class None {
        public:
            None() {
            }
            static None Constructor() { return None(); }
    };
    
} // namespace Language::Core



// ============================================
// Module: __main__
// ============================================
// Import: System
int main() {
    using namespace Language::Core;
    using namespace System;
    
    Language::Runtime::Owned<Language::Core::Integer> num = Language::Core::Integer(10);
    Language::Runtime::Owned<Language::Core::String> result = num.get().add(Language::Core::Integer(53)).get().toString();
    System::Console::printLine(Language::Core::String(reinterpret_cast<const unsigned char*>("Result: ")).append(std::move(result)));
    Language::Runtime::Owned<Language::Core::String> result2 = num.get().add(Language::Core::Integer(5)).get().multiply(Language::Core::Integer(2)).get().toString();
    System::Console::printLine(Language::Core::String(reinterpret_cast<const unsigned char*>("Result2: ")).append(std::move(result2)));
    System::Console::printLine(Language::Core::String(reinterpret_cast<const unsigned char*>("Method chaining test complete!")));
}


