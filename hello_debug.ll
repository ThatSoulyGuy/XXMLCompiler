; Generated by XXML Compiler v2.0 (LLVM IR Backend)
; Target: LLVM IR 17.0
;

target triple = "x86_64-pc-windows-msvc"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"

; Built-in type definitions
%Integer = type { i64 }
%String = type { ptr, i64 }
%Bool = type { i1 }
%Float = type { float }
%Double = type { double }

; ============================================
; XXML LLVM Runtime Library
; ============================================

; Memory Management
declare ptr @xxml_malloc(i64)
declare void @xxml_free(ptr)
declare ptr @xxml_memcpy(ptr, ptr, i64)
declare ptr @xxml_memset(ptr, i32, i64)
declare ptr @xxml_ptr_read(ptr)
declare void @xxml_ptr_write(ptr, ptr)
declare i8 @xxml_read_byte(ptr)
declare void @xxml_write_byte(ptr, i8)

; Integer Operations
declare ptr @Integer_Constructor(i64)
declare i64 @Integer_getValue(ptr)
declare ptr @Integer_add(ptr, ptr)
declare ptr @Integer_sub(ptr, ptr)
declare ptr @Integer_mul(ptr, ptr)
declare ptr @Integer_div(ptr, ptr)
declare i1 @Integer_eq(ptr, ptr)
declare i1 @Integer_ne(ptr, ptr)
declare i1 @Integer_lt(ptr, ptr)
declare i1 @Integer_le(ptr, ptr)
declare i1 @Integer_gt(ptr, ptr)
declare i1 @Integer_ge(ptr, ptr)
declare i64 @Integer_toInt64(ptr)
declare ptr @Integer_toString(ptr)

; String Operations
declare ptr @String_Constructor(ptr)
declare ptr @String_FromCString(ptr)
declare ptr @String_toCString(ptr)
declare i64 @String_length(ptr)
declare ptr @String_concat(ptr, ptr)
declare i1 @String_equals(ptr, ptr)
declare void @String_destroy(ptr)

; Bool Operations
declare ptr @Bool_Constructor(i1)
declare i1 @Bool_getValue(ptr)
declare ptr @Bool_and(ptr, ptr)
declare ptr @Bool_or(ptr, ptr)
declare ptr @Bool_not(ptr)

; List Operations
declare ptr @List_Constructor()
declare void @List_add(ptr, ptr)
declare ptr @List_get(ptr, i64)
declare i64 @List_size(ptr)

; Console I/O
declare void @Console_print(ptr)
declare void @Console_printLine(ptr)
declare void @Console_printInt(i64)
declare void @Console_printBool(i1)

; System Functions
declare void @xxml_exit(i32)
declare void @exit(i32)

; Optimization attributes
attributes #0 = { noinline nounwind optnone uwtable }
attributes #1 = { nounwind uwtable }
attributes #2 = { alwaysinline nounwind uwtable }

; ============================================
; String Literal Constants
; ============================================
@.str.0 = private unnamed_addr constant [13 x i8] c"Test value: \00"
@.str.1 = private unnamed_addr constant [6 x i8] c"Sum: \00"
@.str.2 = private unnamed_addr constant [23 x i8] c"Hello world from XXML!\00"
@.str.3 = private unnamed_addr constant [23 x i8] c"Hello world from XXML!\00"

; import Language::Core
; import Language::Collections
; import Language::System
; namespace MyNamespace
; constraint MyConstraint
; ============================================
; Class: SomeClass
; Template parameters: 1
; ============================================
%class.SomeClass = type { i8 }

; Method: run
define ptr @SomeClass_run(ptr %this) #1 {
    ; Instantiate owned variable: myT
    %r0 = alloca ptr
    ; DEBUG: Tracking variable myT (%r0) as type: T
    ; template parameter instantiation (not supported): T::::Constructor
    store ptr null, ptr %r0
    %r1 = load ptr, ptr %r0
    %r2 = call ptr @T_getValue(ptr %r1)
    ; DEBUG: Registered %r2 -> T
    %r3 = call ptr @T_add(ptr %r2, i64 53)
    ; DEBUG: Registered %r3 -> T
    %r4 = call ptr @T_toString(ptr %r3)
    ; DEBUG: Registered %r4 -> T
    %r5 = call ptr @Console_printLine(ptr %r4)
    ; DEBUG: Registered %r5 -> Console
    ret ptr null  ; implicit return
}


; ============================================
; Class: MyClass
; ============================================
%class.MyClass = type { ptr }

; Constructor for MyClass
define ptr @MyClass_Constructor(ptr %this) #1 {
    ret ptr %this
}

; Method: getValue
define ptr @MyClass_getValue(ptr %this) #1 {
    %r6 = call ptr @Integer_Constructor(i64 42)
    ; DEBUG: Registered %r6 -> Integer
    ret ptr %r6
}


define i32 @main() #1 {
    ; Instantiate owned variable: myClass
    %r7 = alloca ptr
    ; DEBUG: Tracking variable myClass (%r7) as type: MyNamespace::MyClass
    ; instance method call on expression with unknown type
    store ptr null, ptr %r7
    ; Instantiate owned variable: testValue
    %r8 = alloca ptr
    ; DEBUG: Tracking variable testValue (%r8) as type: Integer
    %r9 = call ptr @Integer_Constructor(i64 42)
    ; DEBUG: Registered %r9 -> Integer
    store ptr %r9, ptr %r8
    ; Instantiate owned variable: testStr
    %r10 = alloca ptr
    ; DEBUG: Tracking variable testStr (%r10) as type: String
    %r11 = load ptr, ptr %r8
    %r12 = call ptr @Integer_toString(ptr %r11)
    ; DEBUG: Registered %r12 -> Integer
    store ptr %r12, ptr %r10
    ; Instantiate owned variable: deez
    %r13 = alloca ptr
    ; DEBUG: Tracking variable deez (%r13) as type: List
    %r14 = call ptr @List_Constructor()
    ; DEBUG: Registered %r14 -> List
    store ptr %r14, ptr %r13
    ; Instantiate owned variable: nutz
    %r15 = alloca ptr
    ; DEBUG: Tracking variable nutz (%r15) as type: MyNamespace::SomeClass
    ; instance method call on expression with unknown type
    store ptr null, ptr %r15
    %r16 = load ptr, ptr %r13
    %r17 = call ptr @Integer_Constructor(i64 5)
    ; DEBUG: Registered %r17 -> Integer
    %r18 = call ptr @List_add(ptr %r16, ptr %r17)
    ; DEBUG: Registered %r18 -> List
    %r19 = load ptr, ptr %r15
    %r20 = call ptr @SomeClass_run(ptr %r19)
    ; DEBUG: Registered %r20 -> SomeClass
    %r21 = call ptr @String_Constructor(ptr @.str.0)
    ; DEBUG: Registered %r21 -> String
    %r22 = call ptr @String_append(ptr %r21, ptr %r10)
    ; DEBUG: Registered %r22 -> String
    %r23 = call ptr @Console_printLine(ptr %r22)
    ; DEBUG: Registered %r23 -> Console
    ; Instantiate owned variable: num1
    %r24 = alloca ptr
    ; DEBUG: Tracking variable num1 (%r24) as type: Integer
    %r25 = call ptr @Integer_Constructor(i64 10)
    ; DEBUG: Registered %r25 -> Integer
    store ptr %r25, ptr %r24
    ; Instantiate owned variable: num2
    %r26 = alloca ptr
    ; DEBUG: Tracking variable num2 (%r26) as type: Integer
    %r27 = call ptr @Integer_Constructor(i64 32)
    ; DEBUG: Registered %r27 -> Integer
    store ptr %r27, ptr %r26
    ; Instantiate owned variable: sum
    %r28 = alloca ptr
    ; DEBUG: Tracking variable sum (%r28) as type: Integer
    %r29 = load ptr, ptr %r24
    %r30 = call ptr @Integer_add(ptr %r29, ptr %r26)
    ; DEBUG: Registered %r30 -> Integer
    store ptr %r30, ptr %r28
    ; Instantiate owned variable: sumStr
    %r31 = alloca ptr
    ; DEBUG: Tracking variable sumStr (%r31) as type: String
    %r32 = load ptr, ptr %r28
    %r33 = call ptr @Integer_toString(ptr %r32)
    ; DEBUG: Registered %r33 -> Integer
    store ptr %r33, ptr %r31
    %r34 = call ptr @String_Constructor(ptr @.str.1)
    ; DEBUG: Registered %r34 -> String
    %r35 = call ptr @String_append(ptr %r34, ptr %r31)
    ; DEBUG: Registered %r35 -> String
    %r36 = call ptr @Console_printLine(ptr %r35)
    ; DEBUG: Registered %r36 -> Console
    %r37 = call ptr @String_Constructor(ptr @.str.2)
    ; DEBUG: Registered %r37 -> String
    %r38 = load ptr, ptr %r13
    %r39 = call ptr @Integer_Constructor(i64 0)
    ; DEBUG: Registered %r39 -> Integer
    %r40 = call ptr @List_get(ptr %r38, ptr %r39)
    ; DEBUG: Collection method get, looking up instanceRegister %r13
    ; DEBUG: Found instance type: List
    ; DEBUG: No template args, using class name: List
    ; DEBUG: Registered %r40 -> List
    %r41 = call ptr @List_toString(ptr %r40)
    ; DEBUG: Registered %r41 -> List
    %r42 = call ptr @String_append(ptr %r37, ptr %r41)
    ; DEBUG: Registered %r42 -> String
    %r43 = call ptr @Console_printLine(ptr %r42)
    ; DEBUG: Registered %r43 -> Console
    %r44 = call ptr @String_Constructor(ptr @.str.3)
    ; DEBUG: Registered %r44 -> String
    %r45 = call ptr @Console_printLine(ptr %r44)
    ; DEBUG: Registered %r45 -> Console
    ret i32 0
}
