// Generated by XXML Compiler

#include <iostream>
#include <string>
#include <memory>
#include <cstdint>
#include <cstring>

// Syscall intrinsic functions
class Syscall {
public:
    static void* string_create(const void* cstr) {
        return (void*)new std::string((const char*)cstr);
    }
    static const char* string_cstr(void* ptr) {
        return ((std::string*)ptr)->c_str();
    }
    static int64_t string_length(void* ptr) {
        return ((std::string*)ptr)->length();
    }
    static void* string_concat(void* ptr1, void* ptr2) {
        std::string* s1 = (std::string*)ptr1;
        std::string* s2 = (std::string*)ptr2;
        return (void*)new std::string(*s1 + *s2);
    }
    static void* string_copy(void* ptr) {
        return (void*)new std::string(*(std::string*)ptr);
    }
    static int64_t string_equals(void* ptr1, void* ptr2) {
        return (*(std::string*)ptr1 == *(std::string*)ptr2) ? 1 : 0;
    }
    static void string_destroy(void* ptr) {
        delete (std::string*)ptr;
    }
    static void memcpy(void* dest, const void* src, size_t n) {
        std::memcpy(dest, src, n);
    }
};

// StringArray stub
class StringArray {
public:
    StringArray() {}
    static StringArray Constructor() { return StringArray(); }
};

// Forward declarations
namespace Language::Core {
    class Bool;
    class Integer;
    class Float;
    class Double;
    class String;
}
namespace System {
    class Console;
}

// ============================================
// Core Library - Class Declarations
// ============================================

namespace Language::Core {

    class Integer {
        private:
            int64_t value;
        public:
            Integer() = default;
            Integer(int64_t val) : value(val) {}
            static Integer Constructor(int64_t val) { return Integer(val); }
            int64_t toInt64();
            Language::Core::Integer add(Language::Core::Integer other);
            Language::Core::Integer subtract(Language::Core::Integer other);
            Language::Core::Integer multiply(Language::Core::Integer other);
            Language::Core::Integer divide(Language::Core::Integer other);
            Language::Core::Integer modulo(Language::Core::Integer other);
            Language::Core::Bool equals(Language::Core::Integer other);
            Language::Core::Bool lessThan(Language::Core::Integer other);
            Language::Core::Bool greaterThan(Language::Core::Integer other);
            Language::Core::Bool lessOrEqual(Language::Core::Integer other);
            Language::Core::Bool greaterOrEqual(Language::Core::Integer other);
            Language::Core::Integer negate();
            Language::Core::Integer abs();
    };
    
} // namespace Language::Core

namespace Language::Core {

    class Bool {
        private:
            bool value;
        public:
            Bool() = default;
            Bool(bool val) : value(val) {}
            static Bool Constructor(bool val) { return Bool(val); }
            bool toBool();
            Language::Core::Bool and_(Language::Core::Bool other);
            Language::Core::Bool or_(Language::Core::Bool other);
            Language::Core::Bool not_();
            Language::Core::Bool xor_(Language::Core::Bool other);
            Language::Core::Bool equals(Language::Core::Bool other);
            Language::Core::Integer toInteger();
    };
    
} // namespace Language::Core

namespace Language::Core {

    class Float {
        private:
            float value;
        public:
            Float() = default;
            Float(float val) : value(val) {}
            static Float Constructor(float val) { return Float(val); }
            float toFloat();
            Language::Core::Float add(Language::Core::Float other);
            Language::Core::Float subtract(Language::Core::Float other);
            Language::Core::Float multiply(Language::Core::Float other);
            Language::Core::Float divide(Language::Core::Float other);
            Language::Core::Bool equals(Language::Core::Float other);
            Language::Core::Bool lessThan(Language::Core::Float other);
            Language::Core::Bool greaterThan(Language::Core::Float other);
            Language::Core::Float negate();
            Language::Core::Float abs();
            Language::Core::Integer toInteger();
            Language::Core::Double toDouble();
    };
    
} // namespace Language::Core

namespace Language::Core {

    class Double {
        private:
            double value;
        public:
            Double() = default;
            Double(double val) : value(val) {}
            static Double Constructor(double val) { return Double(val); }
            double toDouble();
            Language::Core::Double add(Language::Core::Double other);
            Language::Core::Double subtract(Language::Core::Double other);
            Language::Core::Double multiply(Language::Core::Double other);
            Language::Core::Double divide(Language::Core::Double other);
            Language::Core::Bool equals(Language::Core::Double other);
            Language::Core::Bool lessThan(Language::Core::Double other);
            Language::Core::Bool greaterThan(Language::Core::Double other);
            Language::Core::Bool lessOrEqual(Language::Core::Double other);
            Language::Core::Bool greaterOrEqual(Language::Core::Double other);
            Language::Core::Double negate();
            Language::Core::Double abs();
            Language::Core::Integer toInteger();
            Language::Core::Float toFloat();
    };
    
} // namespace Language::Core

namespace Language::Core {

    class String {
        private:
            void* data;
        public:
            String() = default;
            String(const void* cstr) {
                void* ptr = Syscall::string_create(cstr);
                Syscall::memcpy(&data, &ptr, 8);
            }
            static String Constructor(const void* cstr) { return String(cstr); }
            const void* toCString();
            Language::Core::Integer length();
            Language::Core::Bool isEmpty();
            Language::Core::String append(Language::Core::String other);
            Language::Core::String copy();
            Language::Core::Bool equals(Language::Core::String other);
            void dispose();
    };
    
} // namespace Language::Core

// ============================================
// Core Library - Method Implementations
// ============================================

namespace Language::Core {

        int64_t Language::Core::Integer::toInt64() {
        return value;
    }
    Language::Core::Integer Language::Core::Integer::add(Language::Core::Integer other) {
        int64_t v1 = value;
        int64_t v2 = other.value;
        int64_t result = v1 + v2;
        return Language::Core::Integer(result);
    }
    Language::Core::Integer Language::Core::Integer::subtract(Language::Core::Integer other) {
        int64_t v1 = value;
        int64_t v2 = other.value;
        int64_t result = v1 - v2;
        return Language::Core::Integer(result);
    }
    Language::Core::Integer Language::Core::Integer::multiply(Language::Core::Integer other) {
        int64_t v1 = value;
        int64_t v2 = other.value;
        int64_t result = v1 * v2;
        return Language::Core::Integer(result);
    }
    Language::Core::Integer Language::Core::Integer::divide(Language::Core::Integer other) {
        int64_t v1 = value;
        int64_t v2 = other.value;
        int64_t result = v1 / v2;
        return Language::Core::Integer(result);
    }
    Language::Core::Integer Language::Core::Integer::modulo(Language::Core::Integer other) {
        int64_t v1 = value;
        int64_t v2 = other.value;
        int64_t result = v1 % v2;
        return Language::Core::Integer(result);
    }
    Language::Core::Bool Language::Core::Integer::equals(Language::Core::Integer other) {
        int64_t v1 = value;
        int64_t v2 = other.value;
        if (v1 == v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Core::Bool Language::Core::Integer::lessThan(Language::Core::Integer other) {
        int64_t v1 = value;
        int64_t v2 = other.value;
        if (v1 < v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Core::Bool Language::Core::Integer::greaterThan(Language::Core::Integer other) {
        int64_t v1 = value;
        int64_t v2 = other.value;
        if (v1 > v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Core::Bool Language::Core::Integer::lessOrEqual(Language::Core::Integer other) {
        int64_t v1 = value;
        int64_t v2 = other.value;
        if (v1 <= v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Core::Bool Language::Core::Integer::greaterOrEqual(Language::Core::Integer other) {
        int64_t v1 = value;
        int64_t v2 = other.value;
        if (v1 >= v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Core::Integer Language::Core::Integer::negate() {
        int64_t v = value;
        int64_t result = 0 - v;
        return Language::Core::Integer(result);
    }
    Language::Core::Integer Language::Core::Integer::abs() {
        int64_t v = value;
        if (v < 0) {
            int64_t result = 0 - v;
            return Language::Core::Integer(result);
        }
        return Language::Core::Integer(v);
    }
} // namespace Language::Core

namespace Language::Core {

        bool Language::Core::Bool::toBool() {
        return value;
    }
    Language::Core::Bool Language::Core::Bool::and_(Language::Core::Bool other) {
        bool v1 = value;
        bool v2 = other.value;
        bool result = v1 && v2;
        return Language::Core::Bool(result);
    }
    Language::Core::Bool Language::Core::Bool::or_(Language::Core::Bool other) {
        bool v1 = value;
        bool v2 = other.value;
        bool result = v1 || v2;
        return Language::Core::Bool(result);
    }
    Language::Core::Bool Language::Core::Bool::not_() {
        bool v = value;
        bool result = !v;
        return Language::Core::Bool(result);
    }
    Language::Core::Bool Language::Core::Bool::xor_(Language::Core::Bool other) {
        bool v1 = value;
        bool v2 = other.value;
        if (v1 == v2) {
            return Language::Core::Bool(false);
        }
        return Language::Core::Bool(true);
    }
    Language::Core::Bool Language::Core::Bool::equals(Language::Core::Bool other) {
        bool v1 = value;
        bool v2 = other.value;
        if (v1 == v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Core::Integer Language::Core::Bool::toInteger() {
        bool v = value;
        if (v == true) {
            return Language::Core::Integer(1);
        }
        return Language::Core::Integer(0);
    }
} // namespace Language::Core

namespace Language::Core {

        float Language::Core::Float::toFloat() {
        return value;
    }
    Language::Core::Float Language::Core::Float::add(Language::Core::Float other) {
        float v1 = value;
        float v2 = other.value;
        float result = v1 + v2;
        return Language::Core::Float(result);
    }
    Language::Core::Float Language::Core::Float::subtract(Language::Core::Float other) {
        float v1 = value;
        float v2 = other.value;
        float result = v1 - v2;
        return Language::Core::Float(result);
    }
    Language::Core::Float Language::Core::Float::multiply(Language::Core::Float other) {
        float v1 = value;
        float v2 = other.value;
        float result = v1 * v2;
        return Language::Core::Float(result);
    }
    Language::Core::Float Language::Core::Float::divide(Language::Core::Float other) {
        float v1 = value;
        float v2 = other.value;
        float result = v1 / v2;
        return Language::Core::Float(result);
    }
    Language::Core::Bool Language::Core::Float::equals(Language::Core::Float other) {
        float v1 = value;
        float v2 = other.value;
        if (v1 == v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Core::Bool Language::Core::Float::lessThan(Language::Core::Float other) {
        float v1 = value;
        float v2 = other.value;
        if (v1 < v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Core::Bool Language::Core::Float::greaterThan(Language::Core::Float other) {
        float v1 = value;
        float v2 = other.value;
        if (v1 > v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Core::Float Language::Core::Float::negate() {
        float v = value;
        float zero = 0;
        float result = zero - v;
        return Language::Core::Float(result);
    }
    Language::Core::Float Language::Core::Float::abs() {
        float v = value;
        float zero = 0;
        if (v < zero) {
            float result = zero - v;
            return Language::Core::Float(result);
        }
        return Language::Core::Float(v);
    }
    Language::Core::Integer Language::Core::Float::toInteger() {
        float v = value;
        int64_t result = v;
        return Language::Core::Integer(result);
    }
    Language::Core::Double Language::Core::Float::toDouble() {
        float v = value;
        double result = v;
        return Language::Core::Double(result);
    }
} // namespace Language::Core

namespace Language::Core {

        double Language::Core::Double::toDouble() {
        return value;
    }
    Language::Core::Double Language::Core::Double::add(Language::Core::Double other) {
        double v1 = value;
        double v2 = other.value;
        double result = v1 + v2;
        return Language::Core::Double(result);
    }
    Language::Core::Double Language::Core::Double::subtract(Language::Core::Double other) {
        double v1 = value;
        double v2 = other.value;
        double result = v1 - v2;
        return Language::Core::Double(result);
    }
    Language::Core::Double Language::Core::Double::multiply(Language::Core::Double other) {
        double v1 = value;
        double v2 = other.value;
        double result = v1 * v2;
        return Language::Core::Double(result);
    }
    Language::Core::Double Language::Core::Double::divide(Language::Core::Double other) {
        double v1 = value;
        double v2 = other.value;
        double result = v1 / v2;
        return Language::Core::Double(result);
    }
    Language::Core::Bool Language::Core::Double::equals(Language::Core::Double other) {
        double v1 = value;
        double v2 = other.value;
        if (v1 == v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Core::Bool Language::Core::Double::lessThan(Language::Core::Double other) {
        double v1 = value;
        double v2 = other.value;
        if (v1 < v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Core::Bool Language::Core::Double::greaterThan(Language::Core::Double other) {
        double v1 = value;
        double v2 = other.value;
        if (v1 > v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Core::Bool Language::Core::Double::lessOrEqual(Language::Core::Double other) {
        double v1 = value;
        double v2 = other.value;
        if (v1 <= v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Core::Bool Language::Core::Double::greaterOrEqual(Language::Core::Double other) {
        double v1 = value;
        double v2 = other.value;
        if (v1 >= v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Core::Double Language::Core::Double::negate() {
        double v = value;
        double zero = 0;
        double result = zero - v;
        return Language::Core::Double(result);
    }
    Language::Core::Double Language::Core::Double::abs() {
        double v = value;
        double zero = 0;
        if (v < zero) {
            double result = zero - v;
            return Language::Core::Double(result);
        }
        return Language::Core::Double(v);
    }
    Language::Core::Integer Language::Core::Double::toInteger() {
        double v = value;
        int64_t result = v;
        return Language::Core::Integer(result);
    }
    Language::Core::Float Language::Core::Double::toFloat() {
        double v = value;
        float result = v;
        return Language::Core::Float(result);
    }
} // namespace Language::Core

namespace Language::Core {

        const void* Language::Core::String::toCString() {
        void* ptr = data;
        return Syscall::string_cstr(ptr);
    }
    Language::Core::Integer Language::Core::String::length() {
        void* ptr = data;
        int64_t len = Syscall::string_length(ptr);
        return Language::Core::Integer(len);
    }
    Language::Core::Bool Language::Core::String::isEmpty() {
        void* ptr = data;
        int64_t len = Syscall::string_length(ptr);
        if (len == 0) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Core::String Language::Core::String::append(Language::Core::String other) {
        void* ptr1 = data;
        void* ptr2 = other.data;
        void* newPtr = Syscall::string_concat(ptr1, ptr2);
        Syscall::memcpy(&data, &newPtr, 8);
        return this;
    }
    Language::Core::String Language::Core::String::copy() {
        const void* empty = "";
        Language::Core::String result = Language::Core::String(empty);
        void* ptr = data;
        void* newPtr = Syscall::string_copy(ptr);
        Syscall::memcpy(&result.data, &newPtr, 8);
        return result;
    }
    Language::Core::Bool Language::Core::String::equals(Language::Core::String other) {
        void* ptr1 = data;
        void* ptr2 = other.data;
        int64_t result = Syscall::string_equals(ptr1, ptr2);
        if (result == 1) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    void Language::Core::String::dispose() {
        void* ptr = data;
        if (ptr != 0) {
            Syscall::string_destroy(ptr);
            void* zero = 0;
            Syscall::memcpy(&data, &zero, 8);
        }
    }
} // namespace Language::Core

// ============================================
// Module: Language/System/Console.XXML
// ============================================
namespace System {

    class Console {
        public:
            static void print(Language::Core::String message) {
                std::cout << (const char*)message.toCString();
            }
            static void printLine(Language::Core::String message) {
                std::cout << (const char*)message.toCString() << std::endl;
            }
            static void printError(Language::Core::String message) {
                std::cerr << (const char*)message.toCString() << std::endl;
            }
            static void clear() {
                #ifdef _WIN32
                    system("cls");
                #else
                    system("clear");
                #endif
            }
            static Language::Core::String readLine() {
                return Language::Core::String();
            }
            static Language::Core::String readChar() {
                return Language::Core::String();
            }
            static Language::Core::Integer readInt() {
                return Language::Core::Integer(0);
            }
            static void printFormatted(Language::Core::String format, Language::Core::String value) {
            }
            static Language::Core::Integer getTime() {
                return Language::Core::Integer(0);
            }
            static Language::Core::Integer getTimeMillis() {
                return Language::Core::Integer(0);
            }
            static void sleep(Language::Core::Integer milliseconds) {
            }
            static Language::Core::String getEnv(Language::Core::String varName) {
                return Language::Core::String();
            }
            static Language::Core::Bool setEnv(Language::Core::String varName, Language::Core::String value) {
                return Language::Core::Bool(false);
            }
            static void exit(Language::Core::Integer exitCode) {
            }
            static StringArray getArgs() {
                return StringArray();
            }
    };
    
} // namespace System



// ============================================
// Module: __main__
// ============================================
int main() {
    using namespace Language::Core;
    
    Language::Core::Integer num1 = Language::Core::Integer(10);
    Language::Core::Integer num2 = Language::Core::Integer(20);
    Language::Core::Integer sum = num1.add(num2);
    Language::Core::Integer product = num1.multiply(num2);
    Language::Core::String message = Language::Core::String("XXML Demo Success!");
    Language::Core::String hello = Language::Core::String("Hello");
    Language::Core::String world = Language::Core::String(" World");
    hello.append(world);
    Language::Core::Integer length = message.length();
    Language::Core::Bool isEqual = num1.equals(num2);
    Language::Core::Bool isLess = num1.lessThan(num2);
    Language::Core::Integer difference = num2.subtract(num1);
    Language::Core::Integer negative = num1.negate();
}



