// XXML Standard Library - Threading Classes
// Concurrent programming support with threads and synchronization
// Backed by platform-native threading (Windows threads / pthreads)

#import Language::Core;

[ Namespace <Concurrent>

    // ============================================
    // Thread Class
    // Represents an execution thread
    // ============================================
    [ Class <Thread> Final Extends None

        [ Private <>
            // Thread handle (opaque pointer to native thread)
            Property <handle> Types NativeType<"ptr">^;
            Property <isValid> Types NativeType<"int64">^;
        ]

        [ Public <>
            // Default constructor - creates uninitialized thread
            Constructor Parameters () ->
            {
                Instantiate NativeType<"ptr">^ As <zero> = 0;
                Instantiate NativeType<"int64">^ As <zeroInt> = 0;
                Run Syscall::memcpy(&handle, &zero, 8);
                Run Syscall::memcpy(&isValid, &zeroInt, 8);
            }

            // Constructor that spawns a thread with a lambda
            // Usage: Thread::Constructor(myLambda)
            Method <Constructor> Returns Thread^ Parameters (
                Parameter <func> Types F(None^)()^
            ) Do {
                Instantiate NativeType<"ptr">^ As <h> = Syscall::Thread_spawn_lambda(func);
                Run Syscall::memcpy(&handle, &h, 8);

                If (h != 0) -> {
                    Instantiate NativeType<"int64">^ As <one> = 1;
                    Run Syscall::memcpy(&isValid, &one, 8);
                } Else -> {
                    Instantiate NativeType<"int64">^ As <zero> = 0;
                    Run Syscall::memcpy(&isValid, &zero, 8);
                }

                Return this;
            }

            // Wait for the thread to complete
            Method <join> Returns Bool^ Parameters () Do {
                Instantiate NativeType<"int64">^ As <valid> = isValid;

                If (valid == 0) -> {
                    Return Bool::Constructor(false);
                }

                Instantiate NativeType<"ptr">^ As <h> = handle;
                Instantiate NativeType<"int64">^ As <result> = Syscall::Thread_join(h);

                // Mark as no longer valid after join
                Instantiate NativeType<"int64">^ As <zero> = 0;
                Run Syscall::memcpy(&isValid, &zero, 8);

                Return Bool::Constructor(result == 0);
            }

            // Detach the thread (let it run independently)
            Method <detach> Returns Bool^ Parameters () Do {
                Instantiate NativeType<"int64">^ As <valid> = isValid;

                If (valid == 0) -> {
                    Return Bool::Constructor(false);
                }

                Instantiate NativeType<"ptr">^ As <h> = handle;
                Instantiate NativeType<"int64">^ As <result> = Syscall::Thread_detach(h);

                // Mark as no longer valid after detach
                Instantiate NativeType<"int64">^ As <zero> = 0;
                Run Syscall::memcpy(&isValid, &zero, 8);

                Return Bool::Constructor(result == 0);
            }

            // Check if thread is joinable
            Method <isJoinable> Returns Bool^ Parameters () Do {
                Instantiate NativeType<"int64">^ As <valid> = isValid;

                If (valid == 0) -> {
                    Return Bool::Constructor(false);
                }

                Instantiate NativeType<"ptr">^ As <h> = handle;
                Instantiate NativeType<"int64">^ As <result> = Syscall::Thread_isJoinable(h);

                Return Bool::Constructor(result != 0);
            }

            // Static: Spawn a new thread with a lambda
            // Returns the thread object
            Method <spawn> Returns Thread^ Parameters (
                Parameter <func> Types F(None^)()^
            ) Do {
                Return Thread::Constructor(func);
            }

            // Static: Sleep current thread for milliseconds
            Method <sleep> Returns None Parameters (Parameter <milliseconds> Types Integer^) Do {
                Instantiate NativeType<"int64">^ As <ms> = milliseconds.toInt64();
                Run Syscall::Thread_sleep(ms);
            }

            // Static: Yield current thread's time slice
            Method <yield> Returns None Parameters () Do {
                Run Syscall::Thread_yield();
            }

            // Static: Get current thread ID
            Method <currentId> Returns Integer^ Parameters () Do {
                Instantiate NativeType<"int64">^ As <id> = Syscall::Thread_currentId();
                Return Integer::Constructor(id);
            }
        ]
    ]

    // ============================================
    // Mutex Class
    // Mutual exclusion lock for thread synchronization
    // ============================================
    [ Class <Mutex> Final Extends None

        [ Private <>
            // Mutex handle (opaque pointer to native mutex)
            Property <handle> Types NativeType<"ptr">^;
        ]

        [ Public <>
            // Constructor - creates and initializes the mutex
            Constructor Parameters () ->
            {
                Instantiate NativeType<"ptr">^ As <h> = Syscall::Mutex_create();
                Run Syscall::memcpy(&handle, &h, 8);
            }

            // Destructor - automatically destroy the mutex
            Destructor Parameters () ->
            {
                Instantiate NativeType<"ptr">^ As <h> = handle;
                If (h != 0) -> {
                    Run Syscall::Mutex_destroy(h);
                }
            }

            // Get the native handle (for ConditionVariable)
            Method <getHandle> Returns NativeType<"ptr">^ Parameters () Do {
                Return handle;
            }

            // Lock the mutex (blocking)
            Method <lock> Returns Bool^ Parameters () Do {
                Instantiate NativeType<"ptr">^ As <h> = handle;

                If (h == 0) -> {
                    Return Bool::Constructor(false);
                }

                Instantiate NativeType<"int64">^ As <result> = Syscall::Mutex_lock(h);
                Return Bool::Constructor(result == 0);
            }

            // Unlock the mutex
            Method <unlock> Returns Bool^ Parameters () Do {
                Instantiate NativeType<"ptr">^ As <h> = handle;

                If (h == 0) -> {
                    Return Bool::Constructor(false);
                }

                Instantiate NativeType<"int64">^ As <result> = Syscall::Mutex_unlock(h);
                Return Bool::Constructor(result == 0);
            }

            // Try to lock without blocking
            Method <tryLock> Returns Bool^ Parameters () Do {
                Instantiate NativeType<"ptr">^ As <h> = handle;

                If (h == 0) -> {
                    Return Bool::Constructor(false);
                }

                Instantiate NativeType<"int64">^ As <result> = Syscall::Mutex_tryLock(h);
                Return Bool::Constructor(result != 0);
            }

            // Check if mutex is valid
            Method <isValid> Returns Bool^ Parameters () Do {
                Instantiate NativeType<"ptr">^ As <h> = handle;
                Return Bool::Constructor(h != 0);
            }
        ]
    ]

    // ============================================
    // LockGuard Class (RAII-style scoped lock)
    // Automatically locks on construction and unlocks on destruction
    // ============================================
    [ Class <LockGuard> Final Extends None

        [ Private <>
            Property <mutexRef> Types NativeType<"ptr">^;
            Property <ownsLock> Types NativeType<"int64">^;
        ]

        [ Public <>
            // Constructor - acquires the lock
            Constructor Parameters (Parameter <mutex> Types Mutex&) ->
            {
                Instantiate NativeType<"ptr">^ As <h> = mutex.getHandle();
                Run Syscall::memcpy(&mutexRef, &h, 8);

                Instantiate NativeType<"int64">^ As <result> = Syscall::Mutex_lock(h);

                If (result == 0) -> {
                    Instantiate NativeType<"int64">^ As <one> = 1;
                    Run Syscall::memcpy(&ownsLock, &one, 8);
                } Else -> {
                    Instantiate NativeType<"int64">^ As <zero> = 0;
                    Run Syscall::memcpy(&ownsLock, &zero, 8);
                }
            }

            // Destructor - releases the lock
            Destructor Parameters () ->
            {
                Instantiate NativeType<"int64">^ As <owns> = ownsLock;
                If (owns != 0) -> {
                    Instantiate NativeType<"ptr">^ As <h> = mutexRef;
                    Run Syscall::Mutex_unlock(h);
                }
            }

            // Check if lock is held
            Method <ownsTheLock> Returns Bool^ Parameters () Do {
                Instantiate NativeType<"int64">^ As <owns> = ownsLock;
                Return Bool::Constructor(owns != 0);
            }

            // Manually release the lock early
            Method <unlock> Returns None Parameters () Do {
                Instantiate NativeType<"int64">^ As <owns> = ownsLock;
                If (owns != 0) -> {
                    Instantiate NativeType<"ptr">^ As <h> = mutexRef;
                    Run Syscall::Mutex_unlock(h);

                    Instantiate NativeType<"int64">^ As <zero> = 0;
                    Run Syscall::memcpy(&ownsLock, &zero, 8);
                }
            }
        ]
    ]

    // ============================================
    // ConditionVariable Class
    // For thread coordination and signaling
    // ============================================
    [ Class <ConditionVariable> Final Extends None

        [ Private <>
            Property <handle> Types NativeType<"ptr">^;
        ]

        [ Public <>
            // Constructor - creates the condition variable
            Constructor Parameters () ->
            {
                Instantiate NativeType<"ptr">^ As <h> = Syscall::CondVar_create();
                Run Syscall::memcpy(&handle, &h, 8);
            }

            // Destructor - destroys the condition variable
            Destructor Parameters () ->
            {
                Instantiate NativeType<"ptr">^ As <h> = handle;
                If (h != 0) -> {
                    Run Syscall::CondVar_destroy(h);
                }
            }

            // Wait on condition (must hold mutex)
            // Atomically releases mutex and waits, reacquires on return
            Method <wait> Returns Bool^ Parameters (Parameter <mutex> Types Mutex&) Do {
                Instantiate NativeType<"ptr">^ As <cond> = handle;
                Instantiate NativeType<"ptr">^ As <mtx> = mutex.getHandle();

                If (cond == 0) -> {
                    Return Bool::Constructor(false);
                }

                Instantiate NativeType<"int64">^ As <result> = Syscall::CondVar_wait(cond, mtx);
                Return Bool::Constructor(result == 0);
            }

            // Wait with timeout (milliseconds)
            // Returns: 0=signaled, 1=timeout, -1=error
            Method <waitTimeout> Returns Integer^ Parameters (
                Parameter <mutex> Types Mutex&,
                Parameter <timeoutMs> Types Integer^
            ) Do {
                Instantiate NativeType<"ptr">^ As <cond> = handle;
                Instantiate NativeType<"ptr">^ As <mtx> = mutex.getHandle();
                Instantiate NativeType<"int64">^ As <timeout> = timeoutMs.toInt64();

                If (cond == 0) -> {
                    Return Integer::Constructor(-1);
                }

                Instantiate NativeType<"int64">^ As <result> = Syscall::CondVar_waitTimeout(cond, mtx, timeout);
                Return Integer::Constructor(result);
            }

            // Signal one waiting thread
            Method <signal> Returns Bool^ Parameters () Do {
                Instantiate NativeType<"ptr">^ As <h> = handle;

                If (h == 0) -> {
                    Return Bool::Constructor(false);
                }

                Instantiate NativeType<"int64">^ As <result> = Syscall::CondVar_signal(h);
                Return Bool::Constructor(result == 0);
            }

            // Signal all waiting threads
            Method <broadcast> Returns Bool^ Parameters () Do {
                Instantiate NativeType<"ptr">^ As <h> = handle;

                If (h == 0) -> {
                    Return Bool::Constructor(false);
                }

                Instantiate NativeType<"int64">^ As <result> = Syscall::CondVar_broadcast(h);
                Return Bool::Constructor(result == 0);
            }

            // Check if condition variable is valid
            Method <isValid> Returns Bool^ Parameters () Do {
                Instantiate NativeType<"ptr">^ As <h> = handle;
                Return Bool::Constructor(h != 0);
            }
        ]
    ]

    // ============================================
    // Atomic Class
    // Thread-safe atomic integer operations
    // ============================================
    [ Class <Atomic> Final Extends None

        [ Private <>
            Property <handle> Types NativeType<"ptr">^;
        ]

        [ Public <>
            // Default constructor - initializes to 0
            Constructor Parameters () ->
            {
                Instantiate NativeType<"int64">^ As <zero> = 0;
                Instantiate NativeType<"ptr">^ As <h> = Syscall::Atomic_create(zero);
                Run Syscall::memcpy(&handle, &h, 8);
            }

            // Constructor with initial value
            Method <Constructor> Returns Atomic^ Parameters (Parameter <initialValue> Types Integer^) Do {
                Instantiate NativeType<"int64">^ As <val> = initialValue.toInt64();
                Instantiate NativeType<"ptr">^ As <h> = Syscall::Atomic_create(val);
                Run Syscall::memcpy(&handle, &h, 8);
                Return this;
            }

            // Destructor - destroys the atomic
            Destructor Parameters () ->
            {
                Instantiate NativeType<"ptr">^ As <h> = handle;
                If (h != 0) -> {
                    Run Syscall::Atomic_destroy(h);
                }
            }

            // Atomically load value
            Method <get> Returns Integer^ Parameters () Do {
                Instantiate NativeType<"ptr">^ As <h> = handle;

                If (h == 0) -> {
                    Return Integer::Constructor(0);
                }

                Instantiate NativeType<"int64">^ As <value> = Syscall::Atomic_load(h);
                Return Integer::Constructor(value);
            }

            // Atomically store value
            Method <set> Returns None Parameters (Parameter <newValue> Types Integer^) Do {
                Instantiate NativeType<"ptr">^ As <h> = handle;

                If (h != 0) -> {
                    Instantiate NativeType<"int64">^ As <val> = newValue.toInt64();
                    Run Syscall::Atomic_store(h, val);
                }
            }

            // Atomically add and return new value
            Method <add> Returns Integer^ Parameters (Parameter <value> Types Integer^) Do {
                Instantiate NativeType<"ptr">^ As <h> = handle;

                If (h == 0) -> {
                    Return Integer::Constructor(0);
                }

                Instantiate NativeType<"int64">^ As <val> = value.toInt64();
                Instantiate NativeType<"int64">^ As <result> = Syscall::Atomic_add(h, val);
                Return Integer::Constructor(result);
            }

            // Atomically subtract and return new value
            Method <subtract> Returns Integer^ Parameters (Parameter <value> Types Integer^) Do {
                Instantiate NativeType<"ptr">^ As <h> = handle;

                If (h == 0) -> {
                    Return Integer::Constructor(0);
                }

                Instantiate NativeType<"int64">^ As <val> = value.toInt64();
                Instantiate NativeType<"int64">^ As <result> = Syscall::Atomic_sub(h, val);
                Return Integer::Constructor(result);
            }

            // Atomically increment and return new value
            Method <increment> Returns Integer^ Parameters () Do {
                Return add(Integer::Constructor(1));
            }

            // Atomically decrement and return new value
            Method <decrement> Returns Integer^ Parameters () Do {
                Return subtract(Integer::Constructor(1));
            }

            // Compare and swap: if current == expected, set to desired
            // Returns true if swap was performed
            Method <compareAndSwap> Returns Bool^ Parameters (
                Parameter <expected> Types Integer^,
                Parameter <desired> Types Integer^
            ) Do {
                Instantiate NativeType<"ptr">^ As <h> = handle;

                If (h == 0) -> {
                    Return Bool::Constructor(false);
                }

                Instantiate NativeType<"int64">^ As <exp> = expected.toInt64();
                Instantiate NativeType<"int64">^ As <des> = desired.toInt64();
                Instantiate NativeType<"int64">^ As <result> = Syscall::Atomic_compareAndSwap(h, exp, des);

                Return Bool::Constructor(result != 0);
            }

            // Exchange: set new value and return old value
            Method <exchange> Returns Integer^ Parameters (Parameter <newValue> Types Integer^) Do {
                Instantiate NativeType<"ptr">^ As <h> = handle;

                If (h == 0) -> {
                    Return Integer::Constructor(0);
                }

                Instantiate NativeType<"int64">^ As <val> = newValue.toInt64();
                Instantiate NativeType<"int64">^ As <result> = Syscall::Atomic_exchange(h, val);
                Return Integer::Constructor(result);
            }

            // Check if atomic is valid
            Method <isValid> Returns Bool^ Parameters () Do {
                Instantiate NativeType<"ptr">^ As <h> = handle;
                Return Bool::Constructor(h != 0);
            }
        ]
    ]

    // ============================================
    // ThreadLocal Class (Template)
    // Thread-local storage for per-thread data
    // ============================================
    [ Class <ThreadLocal> <T Constrains None> Final Extends None

        [ Private <>
            Property <handle> Types NativeType<"ptr">^;
        ]

        [ Public <>
            // Constructor - creates the TLS key
            Constructor Parameters () ->
            {
                Instantiate NativeType<"ptr">^ As <h> = Syscall::TLS_create();
                Run Syscall::memcpy(&handle, &h, 8);
            }

            // Destructor - destroys the TLS key
            Destructor Parameters () ->
            {
                Instantiate NativeType<"ptr">^ As <h> = handle;
                If (h != 0) -> {
                    Run Syscall::TLS_destroy(h);
                }
            }

            // Get thread-local value
            Method <get> Returns T^ Parameters () Do {
                Instantiate NativeType<"ptr">^ As <h> = handle;

                If (h == 0) -> {
                    // Return default - caller should check isSet first
                    Instantiate T^ As <defaultVal> = T::Constructor();
                    Return defaultVal;
                }

                Instantiate NativeType<"ptr">^ As <ptr> = Syscall::TLS_get(h);

                // Cast the pointer back to T^
                Instantiate T^ As <result> = ptr;
                Return result;
            }

            // Set thread-local value
            Method <set> Returns None Parameters (Parameter <value> Types T^) Do {
                Instantiate NativeType<"ptr">^ As <h> = handle;

                If (h != 0) -> {
                    // Store the value pointer
                    Instantiate NativeType<"ptr">^ As <ptr> = value;
                    Run Syscall::TLS_set(h, ptr);
                }
            }

            // Check if a value has been set for this thread
            Method <isSet> Returns Bool^ Parameters () Do {
                Instantiate NativeType<"ptr">^ As <h> = handle;

                If (h == 0) -> {
                    Return Bool::Constructor(false);
                }

                Instantiate NativeType<"ptr">^ As <ptr> = Syscall::TLS_get(h);
                Return Bool::Constructor(ptr != 0);
            }

            // Check if TLS key is valid
            Method <isValid> Returns Bool^ Parameters () Do {
                Instantiate NativeType<"ptr">^ As <h> = handle;
                Return Bool::Constructor(h != 0);
            }
        ]
    ]

    // ============================================
    // Semaphore Class
    // Counting semaphore for resource limiting
    // ============================================
    [ Class <Semaphore> Final Extends None

        [ Private <>
            Property <count> Types Atomic^;
            Property <mutex> Types Mutex^;
            Property <cond> Types ConditionVariable^;
        ]

        [ Public <>
            // Constructor with initial count
            Constructor Parameters (Parameter <initialCount> Types Integer^) ->
            {
                Set count = Atomic::Constructor(initialCount);
                Set mutex = Mutex::Constructor();
                Set cond = ConditionVariable::Constructor();
            }

            // Default constructor - starts at 0
            Constructor Parameters () ->
            {
                Set count = Atomic::Constructor(Integer::Constructor(0));
                Set mutex = Mutex::Constructor();
                Set cond = ConditionVariable::Constructor();
            }

            // Acquire (decrement) - blocks if count is 0
            Method <acquire> Returns None Parameters () Do {
                Run mutex.lock();

                // Wait while count is 0
                Instantiate Integer^ As <c> = count.get();
                While (c.lessThan(Integer::Constructor(1))) -> {
                    Run cond.wait(mutex);
                    Set c = count.get();
                }

                Run count.decrement();
                Run mutex.unlock();
            }

            // Try to acquire without blocking
            Method <tryAcquire> Returns Bool^ Parameters () Do {
                Run mutex.lock();

                Instantiate Integer^ As <c> = count.get();
                If (c.greaterThan(Integer::Constructor(0))) -> {
                    Run count.decrement();
                    Run mutex.unlock();
                    Return Bool::Constructor(true);
                }

                Run mutex.unlock();
                Return Bool::Constructor(false);
            }

            // Release (increment) - wakes one waiting thread
            Method <release> Returns None Parameters () Do {
                Run mutex.lock();
                Run count.increment();
                Run cond.signal();
                Run mutex.unlock();
            }

            // Get current count (approximate, may change immediately)
            Method <getCount> Returns Integer^ Parameters () Do {
                Return count.get();
            }
        ]
    ]
]
