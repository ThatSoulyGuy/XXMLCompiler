// Generic Array<T, N> - Fixed-size array for any type
// T: element type, N: array size (compile-time constant)
// Example: Array<Integer, 10> creates an array of 10 integers
// Replaces IntegerArray, StringArray, etc.

[ Namespace <Language::Collections>
	[ Class <Array> <T Constrains None, N Constrains None> Final Extends None

		[ Private <>
			Property <dataPtr> Types NativeType<"ptr">^;
			Property <arraySize> Types NativeType<"int64">^;
		]

		[ Public <>
			// Constructor - allocate fixed-size array
			Constructor () ->
			{
				// N will be substituted with the actual size at instantiation
				Instantiate NativeType<"int64">^ As <size> = N;
				Set arraySize = size;
				Instantiate NativeType<"ptr">^ As <ptr> = Syscall::malloc(N * 8);
				Set dataPtr = ptr;

				// Initialize all slots to zero/null
				Instantiate NativeType<"int64">^ As <i> = 0;
				While (i < arraySize) -> {
					Instantiate NativeType<"ptr">^ As <offset> = dataPtr + (i * 8);
					Instantiate NativeType<"int64">^ As <zeroVal> = 0;
					Run Syscall::ptr_write(offset, zeroVal);
					Set i = i + 1;
				}
			}

			// Get element at index (returns borrowed reference)
			// For T& return: returns the ADDRESS of the slot containing T^
			Method <get> Returns T& Parameters (Parameter <index> Types Integer&) Do
			{
				Instantiate NativeType<"int64">^ As <zero> = 0;
				Instantiate NativeType<"int64">^ As <idx> = index.toInt64();

				If (idx < zero) -> {
					Return dataPtr;
				}

				If (idx >= arraySize) -> {
					Return dataPtr;
				}

				// Return the address of the slot (T**), not the value (T^)
				Instantiate NativeType<"ptr">^ As <offset> = dataPtr + (idx * 8);
				Return offset;
			}

			// Set element at index
			Method <set> Returns None Parameters (
				Parameter <index> Types Integer&,
				Parameter <value> Types T^
			) Do
			{
				Instantiate NativeType<"int64">^ As <zero> = 0;
				Instantiate NativeType<"int64">^ As <idx> = index.toInt64();

				If (idx < zero) -> {
					Return;
				}

				If (idx >= arraySize) -> {
					Return;
				}

				Instantiate NativeType<"ptr">^ As <offset> = dataPtr + (idx * 8);
				Run Syscall::ptr_write(offset, value);
			}

			// Get array size
			Method <size> Returns Integer^ Parameters () Do
			{
				Return Integer::Constructor(arraySize);
			}

			// Fill all elements with a value
			Method <fill> Returns None Parameters (Parameter <value> Types T^) Do
			{
				Instantiate NativeType<"int64">^ As <i> = 0;
				While (i < arraySize) -> {
					Instantiate NativeType<"ptr">^ As <offset> = dataPtr + (i * 8);
					Run Syscall::ptr_write(offset, value);
					Set i = i + 1;
				}
			}

			// Check if index is valid
			Method <isValidIndex> Returns Bool^ Parameters (Parameter <index> Types Integer&) Do
			{
				Instantiate NativeType<"int64">^ As <zero> = 0;
				Instantiate NativeType<"int64">^ As <idx> = index.toInt64();
				Return Bool::Constructor(idx >= zero && idx < arraySize);
			}

			// Free the array memory - called automatically by RAII
			Destructor Parameters () ->
			{
				If (dataPtr != 0) -> {
					Run Syscall::free(dataPtr);
					Instantiate NativeType<"ptr">^ As <nullPtr> = 0;
					Set dataPtr = nullPtr;
				}

				Instantiate NativeType<"int64">^ As <zero> = 0;
				Set arraySize = zero;
			}
		]
	]
]
