// Generic Queue<T> - FIFO (First In First Out) data structure
// Implemented as a circular buffer for efficient enqueue/dequeue operations

[ Namespace <Collections>
	[ Class <Queue> <T Constrains None> Final Extends None

		[ Private <>
			Property <dataPtr> Types NativeType<"ptr">^;
			Property <capacity> Types NativeType<"int64">^;
			Property <count> Types NativeType<"int64">^;
			Property <head> Types NativeType<"int64">^;
			Property <tail> Types NativeType<"int64">^;
		]

		[ Public <>
			Constructor () ->
			{
				Instantiate NativeType<"ptr">^ As <nullPtr> = 0;
				Instantiate NativeType<"int64">^ As <zero> = 0;
				Run Syscall::memcpy(&dataPtr, &nullPtr, 8);
				Run Syscall::memcpy(&capacity, &zero, 8);
				Run Syscall::memcpy(&count, &zero, 8);
				Run Syscall::memcpy(&head, &zero, 8);
				Run Syscall::memcpy(&tail, &zero, 8);
			}

			// Enqueue an element at the back
			Method <enqueue> Returns None Parameters (Parameter <value> Types T^) Do
			{
				// Check if we need to resize
				If (count == capacity) -> {
					Instantiate NativeType<"int64">^ As <newCapacity> = capacity * 2;
					If (newCapacity == 0) -> {
						Set newCapacity = 8;
					}

					// Allocate new memory
					Instantiate NativeType<"ptr">^ As <newData> = Syscall::malloc(newCapacity * 8);

					// Copy elements in order from head to tail
					If (dataPtr != 0) -> {
						Instantiate NativeType<"int64">^ As <i> = 0;
						Instantiate NativeType<"int64">^ As <idx> = head;
						While (i < count) -> {
							// Read from old position
							Instantiate NativeType<"ptr">^ As <srcOffset> = dataPtr + (idx * 8);
							Instantiate T^ As <elem> = Syscall::ptr_read(srcOffset);

							// Write to new position (sequential)
							Instantiate NativeType<"ptr">^ As <destOffset> = newData + (i * 8);
							Run Syscall::ptr_write(destOffset, elem);

							// Advance with wraparound
							Instantiate NativeType<"int64">^ As <one> = 1;
							Set idx = idx + one;
							If (idx >= capacity) -> {
								Set idx = 0;
							}
							Set i = i + one;
						}
						Run Syscall::free(dataPtr);
					}

					// Update pointers - now linear from 0
					Run Syscall::memcpy(&dataPtr, &newData, 8);
					Run Syscall::memcpy(&capacity, &newCapacity, 8);
					Instantiate NativeType<"int64">^ As <zero> = 0;
					Run Syscall::memcpy(&head, &zero, 8);
					Run Syscall::memcpy(&tail, &count, 8);
				}

				// Add the element at tail
				Instantiate NativeType<"ptr">^ As <offset> = dataPtr + (tail * 8);
				Run Syscall::ptr_write(offset, value);

				// Advance tail with wraparound
				Instantiate NativeType<"int64">^ As <one> = 1;
				Instantiate NativeType<"int64">^ As <newTail> = tail + one;
				If (newTail >= capacity) -> {
					Set newTail = 0;
				}
				Run Syscall::memcpy(&tail, &newTail, 8);

				Instantiate NativeType<"int64">^ As <newCount> = count + one;
				Run Syscall::memcpy(&count, &newCount, 8);
			}

			// Dequeue element from the front
			Method <dequeue> Returns T^ Parameters () Do
			{
				Instantiate NativeType<"int64">^ As <zero> = 0;

				// Return null if empty
				If (count == zero) -> {
					Instantiate NativeType<"ptr">^ As <nullPtr> = 0;
					Return Syscall::ptr_read(nullPtr);
				}

				// Get the front element
				Instantiate NativeType<"ptr">^ As <offset> = dataPtr + (head * 8);
				Instantiate T^ As <value> = Syscall::ptr_read(offset);

				// Advance head with wraparound
				Instantiate NativeType<"int64">^ As <one> = 1;
				Instantiate NativeType<"int64">^ As <newHead> = head + one;
				If (newHead >= capacity) -> {
					Set newHead = 0;
				}
				Run Syscall::memcpy(&head, &newHead, 8);

				Instantiate NativeType<"int64">^ As <newCount> = count - one;
				Run Syscall::memcpy(&count, &newCount, 8);

				Return value;
			}

			// Peek at the front element without removing it
			Method <peek> Returns T^ Parameters () Do
			{
				Instantiate NativeType<"int64">^ As <zero> = 0;

				// Return null if empty
				If (count == zero) -> {
					Instantiate NativeType<"ptr">^ As <nullPtr> = 0;
					Return Syscall::ptr_read(nullPtr);
				}

				// Get the front element
				Instantiate NativeType<"ptr">^ As <offset> = dataPtr + (head * 8);
				Return Syscall::ptr_read(offset);
			}

			// Get queue size
			Method <size> Returns Integer^ Parameters () Do
			{
				Return Integer::Constructor(count);
			}

			// Check if queue is empty
			Method <isEmpty> Returns Bool^ Parameters () Do
			{
				Return Bool::Constructor(count == 0);
			}

			// Clear the queue
			Method <clear> Returns None Parameters () Do
			{
				Instantiate NativeType<"int64">^ As <zero> = 0;
				Run Syscall::memcpy(&count, &zero, 8);
				Run Syscall::memcpy(&head, &zero, 8);
				Run Syscall::memcpy(&tail, &zero, 8);
			}

			// Free the queue memory
			Method <dispose> Returns None Parameters () Do
			{
				If (dataPtr != 0) -> {
					Run Syscall::free(dataPtr);
					Instantiate NativeType<"ptr">^ As <zero> = 0;
					Run Syscall::memcpy(&dataPtr, &zero, 8);
				}

				Instantiate NativeType<"int64">^ As <zero64> = 0;
				Run Syscall::memcpy(&count, &zero64, 8);
				Run Syscall::memcpy(&capacity, &zero64, 8);
				Run Syscall::memcpy(&head, &zero64, 8);
				Run Syscall::memcpy(&tail, &zero64, 8);
			}
		]
	]
]
