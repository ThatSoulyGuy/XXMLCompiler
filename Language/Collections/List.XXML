// Generic List<T> - Dynamic resizable list for any type
// Replaces IntegerList, StringList, etc.

#import Language::Collections::ListIterator;

[ Namespace <Language::Collections>
	[ Class <List> <T Constrains None> Final Extends None

		[ Private <>
			Property <dataPtr> Types NativeType<"ptr">^;
			Property <capacity> Types NativeType<"int64">^;
			Property <count> Types NativeType<"int64">^;
		]

		[ Public <>
			// Constructor - initializes empty list
			Constructor () ->
			{
				Instantiate NativeType<"ptr">^ As <nullPtr> = 0;
				Instantiate NativeType<"int64">^ As <zero> = 0;
				Set dataPtr = nullPtr;
				Set capacity = zero;
				Set count = zero;
			}

			// Add an element to the list
			Method <add> Returns None Parameters (Parameter <value> Types T^) Do
			{
				// Check if we need to resize
				If (count == capacity) -> {
					Instantiate NativeType<"int64">^ As <newCapacity> = capacity * 2;
					If (newCapacity == 0) -> {
						Set newCapacity = 8;
					}

					// Allocate new memory
					Instantiate NativeType<"ptr">^ As <newData> = Syscall::malloc(newCapacity * 8);

					// Copy old data if any
					If (dataPtr != 0) -> {
						Run Syscall::memcpy(newData, dataPtr, count * 8);
						Run Syscall::free(dataPtr);
					}

					Set dataPtr = newData;
					Set capacity = newCapacity;
				}

				// Add the element
				Instantiate NativeType<"ptr">^ As <offset> = dataPtr + (count * 8);
				Run Syscall::ptr_write(offset, value);

				Instantiate NativeType<"int64">^ As <newCount> = count + 1;
				Set count = newCount;
			}

			// Get element at index
			Method <get> Returns T^ Parameters (Parameter <index> Types Integer&) Do
			{
				Instantiate NativeType<"int64">^ As <zero> = 0;
				Instantiate NativeType<"int64">^ As <idx> = index.toInt64();

				If (idx < zero) -> {
					Instantiate NativeType<"ptr">^ As <nullPtr> = 0;
					Return Syscall::ptr_read(nullPtr);
				}

				If (idx >= count) -> {
					Instantiate NativeType<"ptr">^ As <nullPtr> = 0;
					Return Syscall::ptr_read(nullPtr);
				}

				Instantiate NativeType<"ptr">^ As <offset> = dataPtr + (idx * 8);
				Return Syscall::ptr_read(offset);
			}

			// Set element at index
			Method <set> Returns None Parameters (
				Parameter <index> Types Integer&,
				Parameter <value> Types T^
			) Do
			{
				Instantiate NativeType<"int64">^ As <zero> = 0;
				Instantiate NativeType<"int64">^ As <idx> = index.toInt64();
				Instantiate NativeType<"int64">^ As <cnt> = count;

				If (idx >= zero) -> {
					If (idx < cnt) -> {
						Instantiate NativeType<"ptr">^ As <offset> = dataPtr + (idx * 8);
						Run Syscall::ptr_write(offset, value);
					}
				}
			}

			// Get list size
			Method <size> Returns Integer^ Parameters () Do
			{
				Return Integer::Constructor(count);
			}

			// Check if list is empty
			Method <isEmpty> Returns Bool^ Parameters () Do
			{
				Return Bool::Constructor(count == 0);
			}

			// Clear the list
			Method <clear> Returns None Parameters () Do
			{
				Instantiate NativeType<"int64">^ As <zero> = 0;
				Set count = zero;
			}

			// Remove element at index
			Method <remove> Returns None Parameters (Parameter <index> Types Integer&) Do
			{
				Instantiate NativeType<"int64">^ As <zero> = 0;
				Instantiate NativeType<"int64">^ As <idx> = index.toInt64();
				Instantiate NativeType<"int64">^ As <cnt> = count;

				// Only proceed if index is valid (>= 0 and < count)
				If (idx >= zero) -> {
					If (idx < cnt) -> {
						// Shift elements down
						Instantiate NativeType<"int64">^ As <i> = idx;
						Instantiate NativeType<"int64">^ As <lastIdx> = cnt - 1;
						While (i < lastIdx) -> {
							Instantiate NativeType<"ptr">^ As <destOffset> = dataPtr + (i * 8);
							Instantiate NativeType<"int64">^ As <nextIdx> = i + 1;
							Instantiate NativeType<"ptr">^ As <srcOffset> = dataPtr + (nextIdx * 8);
							Instantiate T^ As <val> = Syscall::ptr_read(srcOffset);
							Run Syscall::ptr_write(destOffset, val);
							Set i = nextIdx;
						}

						Instantiate NativeType<"int64">^ As <one> = 1;
						Instantiate NativeType<"int64">^ As <newCount> = cnt - one;
						Set count = newCount;
					}
				}
			}

			// Free the list memory - called automatically by RAII
			Destructor Parameters () ->
			{
				If (dataPtr != 0) -> {
					Run Syscall::free(dataPtr);
					Instantiate NativeType<"ptr">^ As <nullPtr> = 0;
					Set dataPtr = nullPtr;
				}
				Instantiate NativeType<"int64">^ As <zero> = 0;
				Set count = zero;
				Set capacity = zero;
			}

			// Iterator support - C++ style begin/end
			// Returns an iterator pointing to the first element
			Method <begin> Returns ListIterator<T>^ Parameters () Do
			{
				Instantiate NativeType<"int64">^ As <zero> = 0;
				Return ListIterator@T::Constructor(dataPtr, count, zero);
			}

			// Returns an iterator pointing past the last element
			Method <end> Returns ListIterator<T>^ Parameters () Do
			{
				Return ListIterator@T::Constructor(dataPtr, count, count);
			}

		]
	]
]
