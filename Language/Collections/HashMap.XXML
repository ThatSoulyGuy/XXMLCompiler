// Generic HashMap<K, V> - Key-Value mapping with O(1) average operations
// Hash table with separate chaining for collision resolution
// Requires K to implement hash() and equals() methods

#import Language::Collections::HashMapIterator;
#import Language::Collections::KeyValuePair;
#import Language::Collections::List;

[ Namespace <Language::Collections>
	[ Class <HashMap> <K Constrains (Hashable, Equatable), V Constrains None> Final Extends None
		[ Private <>
			// Array of bucket pointers (each bucket stores arrays of key-value pairs)
			Property <buckets> Types NativeType<"ptr">^;
			// Array storing keys for each bucket
			Property <bucketKeys> Types NativeType<"ptr">^;
			// Array storing values for each bucket
			Property <bucketValues> Types NativeType<"ptr">^;
			// Array storing count of items in each bucket
			Property <bucketCounts> Types NativeType<"ptr">^;
			// Array storing capacity of each bucket
			Property <bucketCapacities> Types NativeType<"ptr">^;
			// Number of buckets
			Property <numBuckets> Types NativeType<"int64">^;
			// Total number of elements
			Property <count> Types NativeType<"int64">^;
		]

		[ Public <>
			// Constructor - initializes the hash map
			Constructor () ->
			{
				// Initialize with default number of buckets
				Instantiate NativeType<"int64">^ As <initialBuckets> = 16;
				Instantiate NativeType<"int64">^ As <arraySize> = initialBuckets * 8;

				// Allocate bucket arrays
				Instantiate NativeType<"ptr">^ As <keysPtr> = Syscall::malloc(arraySize);
				Instantiate NativeType<"ptr">^ As <valuesPtr> = Syscall::malloc(arraySize);
				Instantiate NativeType<"ptr">^ As <countsPtr> = Syscall::malloc(arraySize);
				Instantiate NativeType<"ptr">^ As <capsPtr> = Syscall::malloc(arraySize);

				// Zero out the arrays
				Run Syscall::memset(keysPtr, 0, arraySize);
				Run Syscall::memset(valuesPtr, 0, arraySize);
				Run Syscall::memset(countsPtr, 0, arraySize);
				Run Syscall::memset(capsPtr, 0, arraySize);

				// Save to properties (keep buckets for struct layout compatibility)
				Instantiate NativeType<"ptr">^ As <nullPtr> = 0;
				Set buckets = nullPtr;
				Set bucketKeys = keysPtr;
				Set bucketValues = valuesPtr;
				Set bucketCounts = countsPtr;
				Set bucketCapacities = capsPtr;
				Set numBuckets = initialBuckets;
				Instantiate NativeType<"int64">^ As <zero> = 0;
				Set count = zero;
			}

			// Put a key-value pair
			Method <put> Returns None Parameters (
				Parameter <key> Types K^,
				Parameter <value> Types V^
			) Do
			{
				// Get hash and bucket index
				Instantiate NativeType<"int64">^ As <hashVal> = key.hash();
				If (hashVal < 0) -> {
					Set hashVal = 0 - hashVal;
				}
				Instantiate NativeType<"int64">^ As <bucketIdx> = hashVal % numBuckets;

				// Get bucket arrays
				Instantiate NativeType<"ptr">^ As <keyPtrOffset> = bucketKeys + (bucketIdx * 8);
				Instantiate NativeType<"ptr">^ As <valuePtrOffset> = bucketValues + (bucketIdx * 8);
				Instantiate NativeType<"ptr">^ As <countOffset> = bucketCounts + (bucketIdx * 8);
				Instantiate NativeType<"ptr">^ As <capOffset> = bucketCapacities + (bucketIdx * 8);

				Instantiate NativeType<"ptr">^ As <keyData> = Syscall::ptr_read(keyPtrOffset);
				Instantiate NativeType<"ptr">^ As <valueData> = Syscall::ptr_read(valuePtrOffset);
				Instantiate NativeType<"int64">^ As <bucketCount> = Syscall::int64_read(countOffset);
				Instantiate NativeType<"int64">^ As <bucketCap> = Syscall::int64_read(capOffset);

				// Search for existing key
				Instantiate NativeType<"int64">^ As <i> = 0;
				While (i < bucketCount) -> {
					Instantiate NativeType<"ptr">^ As <keyElemOffset> = keyData + (i * 8);
					// Read key but null it after use to prevent RAII from freeing HashMap's data
					Instantiate K^ As <existingKey> = Syscall::ptr_read(keyElemOffset);

					Instantiate Bool^ As <keysEqual> = existingKey.equals(key);

					// Null out existingKey to prevent RAII from freeing HashMap's internal data
					Instantiate NativeType<"ptr">^ As <nullPtr1> = 0;
					Run Syscall::memcpy(&existingKey, &nullPtr1, 8);

					If (keysEqual) -> {
						// Key exists - update value
						Instantiate NativeType<"ptr">^ As <valueElemOffset> = valueData + (i * 8);
						Run Syscall::ptr_write(valueElemOffset, value);
						Return;
					}

					Set i = i + 1;
				}

				// Key not found - add new entry
				// Resize bucket if needed
				If (bucketCount == bucketCap) -> {
					Instantiate NativeType<"int64">^ As <newCap> = bucketCap * 2;
					If (newCap == 0) -> {
						Set newCap = 4;
					}

					Instantiate NativeType<"ptr">^ As <newKeyData> = Syscall::malloc(newCap * 8);
					Instantiate NativeType<"ptr">^ As <newValueData> = Syscall::malloc(newCap * 8);

					If (keyData != 0) -> {
						Run Syscall::memcpy(newKeyData, keyData, bucketCount * 8);
						Run Syscall::memcpy(newValueData, valueData, bucketCount * 8);
						Run Syscall::free(keyData);
						Run Syscall::free(valueData);
					}

					Set keyData = newKeyData;
					Set valueData = newValueData;
					Set bucketCap = newCap;
					Run Syscall::ptr_write(keyPtrOffset, keyData);
					Run Syscall::ptr_write(valuePtrOffset, valueData);
					Run Syscall::int64_write(capOffset, bucketCap);
				}

				// Add new entry
				Instantiate NativeType<"ptr">^ As <keyElemOffset> = keyData + (bucketCount * 8);
				Instantiate NativeType<"ptr">^ As <valueElemOffset> = valueData + (bucketCount * 8);
				Run Syscall::ptr_write(keyElemOffset, key);
				Run Syscall::ptr_write(valueElemOffset, value);

				// Update counts
				Instantiate NativeType<"int64">^ As <one> = 1;
				Instantiate NativeType<"int64">^ As <newBucketCount> = bucketCount + one;
				Run Syscall::int64_write(countOffset, newBucketCount);

				Instantiate NativeType<"int64">^ As <newCount> = count + one;
				Set count = newCount;
			}

			// Get value by key, returns null if not found
			// Note: Returns a reference to the stored value, NOT a copy
			Method <get> Returns V& Parameters (Parameter <key> Types K^) Do
			{
				// Get hash and bucket index
				Instantiate NativeType<"int64">^ As <hashVal> = key.hash();
				If (hashVal < 0) -> {
					Set hashVal = 0 - hashVal;
				}
				Instantiate NativeType<"int64">^ As <bucketIdx> = hashVal % numBuckets;

				// Get bucket arrays
				Instantiate NativeType<"ptr">^ As <keyPtrOffset> = bucketKeys + (bucketIdx * 8);
				Instantiate NativeType<"ptr">^ As <valuePtrOffset> = bucketValues + (bucketIdx * 8);
				Instantiate NativeType<"ptr">^ As <countOffset> = bucketCounts + (bucketIdx * 8);

				Instantiate NativeType<"ptr">^ As <keyData> = Syscall::ptr_read(keyPtrOffset);
				Instantiate NativeType<"ptr">^ As <valueData> = Syscall::ptr_read(valuePtrOffset);
				Instantiate NativeType<"int64">^ As <bucketCount> = Syscall::int64_read(countOffset);

				// Empty bucket
				If (keyData == 0) -> {
					Instantiate NativeType<"ptr">^ As <nullPtr> = 0;
					Return Syscall::ptr_read(nullPtr);
				}

				// Search for key
				Instantiate NativeType<"int64">^ As <i> = 0;
				While (i < bucketCount) -> {
					Instantiate NativeType<"ptr">^ As <keyElemOffset> = keyData + (i * 8);
					// Read key but null it after use to prevent RAII from freeing HashMap's data
					Instantiate K^ As <existingKey> = Syscall::ptr_read(keyElemOffset);

					Instantiate Bool^ As <keysEqual> = existingKey.equals(key);

					// Null out existingKey to prevent RAII from freeing HashMap's internal data
					Instantiate NativeType<"ptr">^ As <nullPtr1> = 0;
					Run Syscall::memcpy(&existingKey, &nullPtr1, 8);

					If (keysEqual) -> {
						// Found - return value
						Instantiate NativeType<"ptr">^ As <valueElemOffset> = valueData + (i * 8);
						Return Syscall::ptr_read(valueElemOffset);
					}

					Set i = i + 1;
				}

				// Not found
				Instantiate NativeType<"ptr">^ As <nullPtr> = 0;
				Return Syscall::ptr_read(nullPtr);
			}

			// Check if key exists
			Method <containsKey> Returns Bool^ Parameters (Parameter <key> Types K^) Do
			{
				// Get hash and bucket index
				Instantiate NativeType<"int64">^ As <hashVal> = key.hash();
				If (hashVal < 0) -> {
					Set hashVal = 0 - hashVal;
				}
				Instantiate NativeType<"int64">^ As <bucketIdx> = hashVal % numBuckets;

				// Get bucket arrays
				Instantiate NativeType<"ptr">^ As <keyPtrOffset> = bucketKeys + (bucketIdx * 8);
				Instantiate NativeType<"ptr">^ As <countOffset> = bucketCounts + (bucketIdx * 8);

				Instantiate NativeType<"ptr">^ As <keyData> = Syscall::ptr_read(keyPtrOffset);
				Instantiate NativeType<"int64">^ As <bucketCount> = Syscall::int64_read(countOffset);

				// Empty bucket
				If (keyData == 0) -> {
					Return Bool::Constructor(false);
				}

				// Search for key
				Instantiate NativeType<"int64">^ As <i> = 0;
				While (i < bucketCount) -> {
					Instantiate NativeType<"ptr">^ As <keyElemOffset> = keyData + (i * 8);
					// Read key but null it after use to prevent RAII from freeing HashMap's data
					Instantiate K^ As <existingKey> = Syscall::ptr_read(keyElemOffset);

					Instantiate Bool^ As <keysEqual> = existingKey.equals(key);

					// Null out existingKey to prevent RAII from freeing HashMap's internal data
					Instantiate NativeType<"ptr">^ As <nullPtr1> = 0;
					Run Syscall::memcpy(&existingKey, &nullPtr1, 8);

					If (keysEqual) -> {
						Return Bool::Constructor(true);
					}

					Set i = i + 1;
				}

				Return Bool::Constructor(false);
			}

			// Remove a key-value pair
			Method <remove> Returns Bool^ Parameters (Parameter <key> Types K^) Do
			{
				// Get hash and bucket index
				Instantiate NativeType<"int64">^ As <hashVal> = key.hash();
				If (hashVal < 0) -> {
					Set hashVal = 0 - hashVal;
				}
				Instantiate NativeType<"int64">^ As <bucketIdx> = hashVal % numBuckets;

				// Get bucket arrays
				Instantiate NativeType<"ptr">^ As <keyPtrOffset> = bucketKeys + (bucketIdx * 8);
				Instantiate NativeType<"ptr">^ As <valuePtrOffset> = bucketValues + (bucketIdx * 8);
				Instantiate NativeType<"ptr">^ As <countOffset> = bucketCounts + (bucketIdx * 8);

				Instantiate NativeType<"ptr">^ As <keyData> = Syscall::ptr_read(keyPtrOffset);
				Instantiate NativeType<"ptr">^ As <valueData> = Syscall::ptr_read(valuePtrOffset);
				Instantiate NativeType<"int64">^ As <bucketCount> = Syscall::int64_read(countOffset);

				// Empty bucket
				If (keyData == 0) -> {
					Return Bool::Constructor(false);
				}

				// Search for key
				Instantiate NativeType<"int64">^ As <i> = 0;
				While (i < bucketCount) -> {
					Instantiate NativeType<"ptr">^ As <keyElemOffset> = keyData + (i * 8);
					// Read key but null it after use to prevent RAII from freeing HashMap's data
					Instantiate K^ As <existingKey> = Syscall::ptr_read(keyElemOffset);

					Instantiate Bool^ As <keysEqual> = existingKey.equals(key);

					// Null out existingKey to prevent RAII from freeing HashMap's internal data
					Instantiate NativeType<"ptr">^ As <nullPtr1> = 0;
					Run Syscall::memcpy(&existingKey, &nullPtr1, 8);

					If (keysEqual) -> {
						// Found - shift remaining elements
						Instantiate NativeType<"int64">^ As <j> = i;
						Instantiate NativeType<"int64">^ As <one> = 1;
						Instantiate NativeType<"int64">^ As <lastIdx> = bucketCount - one;

						While (j < lastIdx) -> {
							Instantiate NativeType<"int64">^ As <nextJ> = j + one;

							Instantiate NativeType<"ptr">^ As <destKeyOffset> = keyData + (j * 8);
							Instantiate NativeType<"ptr">^ As <srcKeyOffset> = keyData + (nextJ * 8);
							Instantiate NativeType<"ptr">^ As <nextKeyPtr> = Syscall::ptr_read(srcKeyOffset);
							Run Syscall::ptr_write(destKeyOffset, nextKeyPtr);

							Instantiate NativeType<"ptr">^ As <destValueOffset> = valueData + (j * 8);
							Instantiate NativeType<"ptr">^ As <srcValueOffset> = valueData + (nextJ * 8);
							Instantiate NativeType<"ptr">^ As <nextValuePtr> = Syscall::ptr_read(srcValueOffset);
							Run Syscall::ptr_write(destValueOffset, nextValuePtr);

							Set j = nextJ;
						}

						// Update counts
						Instantiate NativeType<"int64">^ As <newBucketCount> = bucketCount - one;
						Run Syscall::int64_write(countOffset, newBucketCount);

						Instantiate NativeType<"int64">^ As <newCount> = count - one;
						Set count = newCount;

						Return Bool::Constructor(true);
					}

					Set i = i + 1;
				}

				Return Bool::Constructor(false);
			}

			// Get size
			Method <size> Returns Integer^ Parameters () Do
			{
				Return Integer::Constructor(count);
			}

			// Check if empty
			Method <isEmpty> Returns Bool^ Parameters () Do
			{
				Return Bool::Constructor(count == 0);
			}

			// Clear the map
			Method <clear> Returns None Parameters () Do
			{
				// Reset all bucket counts
				Instantiate NativeType<"int64">^ As <i> = 0;
				Instantiate NativeType<"int64">^ As <zero> = 0;
				While (i < numBuckets) -> {
					Instantiate NativeType<"ptr">^ As <countOffset> = bucketCounts + (i * 8);
					Run Syscall::int64_write(countOffset, zero);
					Set i = i + 1;
				}
				Set count = zero;
			}

			// Free the map memory - called automatically by RAII
			Destructor Parameters () ->
			{
				// Free each bucket's key and value arrays
				Instantiate NativeType<"int64">^ As <i> = 0;
				While (i < numBuckets) -> {
					Instantiate NativeType<"ptr">^ As <keyPtrOffset> = bucketKeys + (i * 8);
					Instantiate NativeType<"ptr">^ As <valuePtrOffset> = bucketValues + (i * 8);

					Instantiate NativeType<"ptr">^ As <keyData> = Syscall::ptr_read(keyPtrOffset);
					Instantiate NativeType<"ptr">^ As <valueData> = Syscall::ptr_read(valuePtrOffset);

					If (keyData != 0) -> {
						Run Syscall::free(keyData);
					}
					If (valueData != 0) -> {
						Run Syscall::free(valueData);
					}

					Set i = i + 1;
				}

				// Free bucket arrays
				If (bucketKeys != 0) -> {
					Run Syscall::free(bucketKeys);
				}
				If (bucketValues != 0) -> {
					Run Syscall::free(bucketValues);
				}
				If (bucketCounts != 0) -> {
					Run Syscall::free(bucketCounts);
				}
				If (bucketCapacities != 0) -> {
					Run Syscall::free(bucketCapacities);
				}
				// Note: Not resetting properties to null/zero as object should not be used after destruction
			}

			// Iterator support - C++ style begin
			// Returns an iterator pointing to the first key-value pair
			Method <begin> Returns HashMapIterator<K, V>^ Parameters () Do
			{
				Return HashMapIterator@K, V::Constructor(bucketKeys, bucketValues, bucketCounts, numBuckets, count);
			}

			// Get all keys as a List
			Method <keys> Returns List<K>^ Parameters () Do
			{
				Instantiate List<K>^ As <keyList> = List@K::Constructor();
				Instantiate HashMapIterator<K, V>^ As <iter> = this.begin();
				While (iter.hasNext()) -> {
					Instantiate KeyValuePair<K, V>^ As <pair> = iter.next();
					Run keyList.add(pair.key());
				}
				Return keyList;
			}

			// Get all values as a List
			Method <values> Returns List<V>^ Parameters () Do
			{
				Instantiate List<V>^ As <valueList> = List@V::Constructor();
				Instantiate HashMapIterator<K, V>^ As <iter> = this.begin();
				While (iter.hasNext()) -> {
					Instantiate KeyValuePair<K, V>^ As <pair> = iter.next();
					Run valueList.add(pair.value());
				}
				Return valueList;
			}
		]
	]
]
