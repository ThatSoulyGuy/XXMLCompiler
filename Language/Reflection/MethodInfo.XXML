#import Language::Core;

[ Namespace <Language::Reflection>
	[ Class <MethodInfo> Final Extends None
		[ Private <>
			Property <methodInfoPtr> Types NativeType<"ptr">^;
		]

		[ Public <>
			Constructor Parameters (
				Parameter <infoPtr> Types NativeType<"ptr">%
			) ->
			{
				Run Syscall::memcpy(&methodInfoPtr, &infoPtr, 8);
			}

			// Get method name
			Method <getName> Returns String^ Parameters () ->
			{
				Instantiate NativeType<"ptr">^ As <ptr> = methodInfoPtr;
				Instantiate NativeType<"cstr">^ As <namePtr> =
					Syscall::reflection_method_getName(ptr);
				Return String::FromCString(namePtr);
			}

			// Get return type name
			Method <getReturnType> Returns String^ Parameters () ->
			{
				Instantiate NativeType<"ptr">^ As <ptr> = methodInfoPtr;
				Instantiate NativeType<"cstr">^ As <typePtr> =
					Syscall::reflection_method_getReturnType(ptr);
				Return String::FromCString(typePtr);
			}

			// Get return ownership type (0=None, 1=Owned, 2=Reference, 3=Copy)
			Method <getReturnOwnership> Returns Integer^ Parameters () ->
			{
				Instantiate NativeType<"ptr">^ As <ptr> = methodInfoPtr;
				Instantiate NativeType<"int64">^ As <ownership> =
					Syscall::reflection_method_getReturnOwnership(ptr);
				Return Integer::Constructor(ownership);
			}

			// Get return ownership as human-readable string
			Method <getReturnOwnershipString> Returns String^ Parameters () ->
			{
				Instantiate Integer^ As <ownership> = getReturnOwnership();
				Instantiate NativeType<"int64">^ As <ownershipValue> = ownership.toInt64();

				If (ownershipValue == 0) -> {
					Return String::Constructor("None");
				}
				If (ownershipValue == 1) -> {
					Return String::Constructor("Owned(^)");
				}
				If (ownershipValue == 2) -> {
					Return String::Constructor("Reference(&)");
				}
				If (ownershipValue == 3) -> {
					Return String::Constructor("Copy(%)");
				}

				Return String::Constructor("Unknown");
			}

			// Check if return type is owned (^)
			Method <isReturnOwned> Returns Bool^ Parameters () ->
			{
				Instantiate Integer^ As <ownership> = getReturnOwnership();
				Instantiate NativeType<"int64">^ As <ownershipValue> = ownership.toInt64();
				Instantiate NativeType<"bool">^ As <result> = ownershipValue == 1;
				Return Bool::Constructor(result);
			}

			// Check if return type is a reference (&)
			Method <isReturnReference> Returns Bool^ Parameters () ->
			{
				Instantiate Integer^ As <ownership> = getReturnOwnership();
				Instantiate NativeType<"int64">^ As <ownershipValue> = ownership.toInt64();
				Instantiate NativeType<"bool">^ As <result> = ownershipValue == 2;
				Return Bool::Constructor(result);
			}

			// Check if return type is copy (%)
			Method <isReturnCopy> Returns Bool^ Parameters () ->
			{
				Instantiate Integer^ As <ownership> = getReturnOwnership();
				Instantiate NativeType<"int64">^ As <ownershipValue> = ownership.toInt64();
				Instantiate NativeType<"bool">^ As <result> = ownershipValue == 3;
				Return Bool::Constructor(result);
			}

			// Check if this method mutates the object (non-static, non-constructor)
			// In XXML, non-static methods that aren't getters typically mutate state
			// This is a heuristic: methods with "set", "add", "remove", "clear", "init" in name
			// are considered mutating, along with constructors
			Method <isMutating> Returns Bool^ Parameters () ->
			{
				// Constructors mutate (initialize) the object
				Instantiate Bool^ As <isCtor> = isConstructor();
				If (isCtor) -> {
					Return Bool::Constructor(true);
				}

				// Static methods don't mutate 'this'
				Instantiate Bool^ As <staticCheck> = isStatic();
				If (staticCheck) -> {
					Return Bool::Constructor(false);
				}

				// Heuristic: check method name for common mutation patterns
				Instantiate String^ As <name> = getName();
				Instantiate NativeType<"cstr">^ As <nameStr> = name.toCString();

				// Methods returning None typically mutate state
				Instantiate String^ As <retType> = getReturnType();
				If (retType.equals(String::Constructor("None"))) -> {
					Return Bool::Constructor(true);
				}

				// Methods returning the same type (builder pattern) likely mutate
				// For now, assume non-getter methods with side effects are mutating
				// A more precise analysis would require semantic information

				Return Bool::Constructor(false);
			}

			// Get ownership of parameter at given index
			Method <getParameterOwnership> Returns Integer^ Parameters (
				Parameter <index> Types Integer&
			) ->
			{
				Instantiate ParameterInfo^ As <param> = getParameterAt(index);
				Return param.getOwnership();
			}

			// Get ownership string of parameter at given index
			Method <getParameterOwnershipString> Returns String^ Parameters (
				Parameter <index> Types Integer&
			) ->
			{
				Instantiate ParameterInfo^ As <param> = getParameterAt(index);
				Return param.getOwnershipString();
			}

			// Get parameter count
			Method <getParameterCount> Returns Integer^ Parameters () ->
			{
				Instantiate NativeType<"ptr">^ As <ptr> = methodInfoPtr;
				Instantiate NativeType<"int64">^ As <count> =
					Syscall::reflection_method_getParameterCount(ptr);
				Return Integer::Constructor(count);
			}

			// Get parameter by index
			Method <getParameterAt> Returns ParameterInfo^ Parameters (
				Parameter <index> Types Integer&
			) ->
			{
				Instantiate NativeType<"ptr">^ As <ptr> = methodInfoPtr;
				Instantiate NativeType<"int64">^ As <idx> = index.toInt64();
				Instantiate NativeType<"ptr">^ As <paramPtr> =
					Syscall::reflection_method_getParameter(ptr, idx);

				If (paramPtr == 0) -> {
					Return None::Constructor();
				}

				Return ParameterInfo::Constructor(paramPtr);
			}

			// Check if static method
			Method <isStatic> Returns Bool^ Parameters () ->
			{
				Instantiate NativeType<"ptr">^ As <ptr> = methodInfoPtr;
				Instantiate NativeType<"int64">^ As <result> =
					Syscall::reflection_method_isStatic(ptr);
				Instantiate NativeType<"bool">^ As <b> = result != 0;
				Return Bool::Constructor(b);
			}

			// Check if constructor
			Method <isConstructor> Returns Bool^ Parameters () ->
			{
				Instantiate NativeType<"ptr">^ As <ptr> = methodInfoPtr;
				Instantiate NativeType<"int64">^ As <result> =
					Syscall::reflection_method_isConstructor(ptr);
				Instantiate NativeType<"bool">^ As <b> = result != 0;
				Return Bool::Constructor(b);
			}

			// Get method signature as string
			Method <getSignature> Returns String^ Parameters () ->
			{
				Instantiate String^ As <sig> = String::Constructor("");
				Instantiate String^ As <retType> = getReturnType();
				Instantiate String^ As <name> = getName();

				Run sig.append(retType);
				Run sig.append(String::Constructor(" "));
				Run sig.append(name);
				Run sig.append(String::Constructor("("));

				Instantiate Integer^ As <count> = getParameterCount();
				Instantiate NativeType<"int64">^ As <i> = 0;
				Instantiate NativeType<"int64">^ As <paramCount> = count.toInt64();

				While (i < paramCount) -> {
					If (i > 0) -> {
						Run sig.append(String::Constructor(", "));
					}
					Instantiate ParameterInfo^ As <param> = getParameterAt(Integer::Constructor(i));
					Instantiate String^ As <paramType> = param.getTypeName();
					Run sig.append(paramType);
					Set i = i + 1;
				}

				Run sig.append(String::Constructor(")"));
				Return sig;
			}

			// ============================================
			// Dynamic Method Invocation
			// ============================================

			// Invoke instance method with no arguments
			// Returns the result as a raw pointer (caller must cast appropriately)
			Method <invoke> Returns NativeType<"ptr">^ Parameters (
				Parameter <instance> Types NativeType<"ptr">%
			) ->
			{
				Instantiate NativeType<"ptr">^ As <ptr> = methodInfoPtr;
				Instantiate NativeType<"ptr">^ As <nullArgs> = 0;
				Instantiate NativeType<"int64">^ As <argCount> = 0;
				Return Syscall::reflection_method_invoke(ptr, instance, nullArgs, argCount);
			}

			// Invoke instance method with arguments array
			// args: pointer to array of void* arguments
			// argCount: number of arguments (must match method's parameter count)
			Method <invokeWithArgs> Returns NativeType<"ptr">^ Parameters (
				Parameter <instance> Types NativeType<"ptr">%,
				Parameter <args> Types NativeType<"ptr">%,
				Parameter <argCount> Types Integer&
			) ->
			{
				Instantiate NativeType<"ptr">^ As <ptr> = methodInfoPtr;
				Instantiate NativeType<"int64">^ As <count> = argCount.toInt64();
				Return Syscall::reflection_method_invoke(ptr, instance, args, count);
			}

			// Invoke static method with no arguments
			Method <invokeStatic> Returns NativeType<"ptr">^ Parameters () ->
			{
				Instantiate NativeType<"ptr">^ As <ptr> = methodInfoPtr;
				Instantiate NativeType<"ptr">^ As <nullInstance> = 0;
				Instantiate NativeType<"ptr">^ As <nullArgs> = 0;
				Instantiate NativeType<"int64">^ As <argCount> = 0;
				Return Syscall::reflection_method_invoke(ptr, nullInstance, nullArgs, argCount);
			}

			// Invoke static method with arguments array
			Method <invokeStaticWithArgs> Returns NativeType<"ptr">^ Parameters (
				Parameter <args> Types NativeType<"ptr">%,
				Parameter <argCount> Types Integer&
			) ->
			{
				Instantiate NativeType<"ptr">^ As <ptr> = methodInfoPtr;
				Instantiate NativeType<"ptr">^ As <nullInstance> = 0;
				Instantiate NativeType<"int64">^ As <count> = argCount.toInt64();
				Return Syscall::reflection_method_invoke(ptr, nullInstance, args, count);
			}

			// Get the raw function pointer (for advanced usage)
			Method <getFunctionPointer> Returns NativeType<"ptr">^ Parameters () ->
			{
				Instantiate NativeType<"ptr">^ As <ptr> = methodInfoPtr;
				Return Syscall::reflection_method_getFunctionPointer(ptr);
			}
		]
	]
]
