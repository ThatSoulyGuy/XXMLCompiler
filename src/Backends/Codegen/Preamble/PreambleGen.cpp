#include "Backends/Codegen/Preamble/PreambleGen.h"
#include "Common/Version.h"

namespace XXML {
namespace Backends {
namespace Codegen {

PreambleGen::PreambleGen(TargetPlatform platform)
    : platform_(platform) {
}

std::string PreambleGen::getTargetTriple() const {
    switch (platform_) {
        case TargetPlatform::X86_64_Windows:
            return "x86_64-pc-windows-msvc";
        case TargetPlatform::X86_64_Linux:
            return "x86_64-unknown-linux-gnu";
        case TargetPlatform::X86_64_MacOS:
            return "x86_64-apple-darwin";
        case TargetPlatform::ARM64_Linux:
            return "aarch64-unknown-linux-gnu";
        case TargetPlatform::ARM64_MacOS:
            return "arm64-apple-darwin";
        case TargetPlatform::WebAssembly:
            return "wasm32-unknown-unknown";
        case TargetPlatform::Native:
        default:
#ifdef _WIN32
    #if defined(__MINGW32__) || defined(__MINGW64__)
            return "x86_64-w64-windows-gnu";
    #else
            return "x86_64-pc-windows-msvc";
    #endif
#elif defined(__APPLE__)
    #if defined(__aarch64__) || defined(__arm64__)
            return "arm64-apple-darwin";
    #else
            return "x86_64-apple-darwin";
    #endif
#elif defined(__linux__)
    #if defined(__aarch64__) || defined(__arm64__)
            return "aarch64-unknown-linux-gnu";
    #else
            return "x86_64-unknown-linux-gnu";
    #endif
#else
            return "x86_64-unknown-unknown";
#endif
    }
}

std::string PreambleGen::getDataLayout() const {
    switch (platform_) {
        case TargetPlatform::X86_64_Windows:
        case TargetPlatform::X86_64_Linux:
        case TargetPlatform::X86_64_MacOS:
            return "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128";
        case TargetPlatform::ARM64_Linux:
        case TargetPlatform::ARM64_MacOS:
            return "e-m:o-i64:64-i128:128-n32:64-S128";
        case TargetPlatform::WebAssembly:
            return "e-m:e-p:32:32-i64:64-n32:64-S128";
        case TargetPlatform::Native:
        default:
            return "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128";
    }
}

std::string PreambleGen::generate() const {
    std::stringstream preamble;

    emitHeader(preamble);
    emitTargetInfo(preamble);
    emitBuiltinTypes(preamble);

    preamble << "; ============================================\n";
    preamble << "; XXML LLVM Runtime Library\n";
    preamble << "; ============================================\n\n";

    // Emit all runtime function declarations from the manifest
    manifest_.emitDeclarations(preamble);

    // Platform-specific declarations
    emitWindowsDLLFunctions(preamble);
    emitAttributes(preamble);

    return preamble.str();
}

void PreambleGen::emitHeader(std::stringstream& out) const {
    out << "; Generated by " << XXML_VERSION_FULL << " (LLVM IR Backend)\n";
    out << "; Target: LLVM IR 17.0\n";
    out << ";\n\n";
}

void PreambleGen::emitTargetInfo(std::stringstream& out) const {
    out << "target triple = \"" << getTargetTriple() << "\"\n";
    out << "target datalayout = \"" << getDataLayout() << "\"\n\n";
}

void PreambleGen::emitBuiltinTypes(std::stringstream& out) const {
    out << "; Built-in type definitions\n";
    out << "%Integer = type { i64 }\n";
    out << "%String = type { ptr, i64 }\n";
    out << "%Bool = type { i1 }\n";
    out << "%Float = type { float }\n";
    out << "%Double = type { double }\n";
    out << "\n";

    // Reflection metadata struct types (must match xxml_reflection_runtime.h)
    out << "; Reflection metadata types\n";
    // ReflectionPropertyInfo: name, typeName, ownership, offset, annotationCount, annotations
    out << "%ReflectionPropertyInfo = type { ptr, ptr, i32, i64, i32, ptr }\n";
    // ReflectionParameterInfo: name, typeName, ownership
    out << "%ReflectionParameterInfo = type { ptr, ptr, i32 }\n";
    // ReflectionMethodInfo: name, returnType, returnOwnership, paramCount, params, funcPtr, isStatic, isCtor, annotationCount, annotations
    out << "%ReflectionMethodInfo = type { ptr, ptr, i32, i32, ptr, ptr, i1, i1, i32, ptr }\n";
    // ReflectionTemplateParamInfo: name, isTypeParameter, valueType
    out << "%ReflectionTemplateParamInfo = type { ptr, i1, ptr }\n";
    // ReflectionTypeInfo: name, namespaceName, fullName, isTemplate, templateParamCount, templateParams,
    //   propertyCount, properties, methodCount, methods, constructorCount, constructors,
    //   baseClassName, instanceSize, annotationCount, annotations
    out << "%ReflectionTypeInfo = type { ptr, ptr, ptr, i1, i32, ptr, i32, ptr, i32, ptr, i32, ptr, ptr, i64, i32, ptr }\n";
    out << "\n";
}

void PreambleGen::emitWindowsDLLFunctions(std::stringstream& out) const {
    out << "; Windows kernel32 functions for FFI\n";
    out << "declare dllimport ptr @LoadLibraryA(ptr) #1\n";
    out << "declare dllimport ptr @GetProcAddress(ptr, ptr) #1\n";
    out << "declare dllimport i32 @FreeLibrary(ptr) #1\n";
    out << "\n";
}

void PreambleGen::emitAttributes(std::stringstream& out) const {
    out << "; Optimization attributes\n";
    out << "attributes #0 = { noinline nounwind optnone uwtable }\n";
    out << "attributes #1 = { nounwind uwtable }\n";
    out << "attributes #2 = { alwaysinline nounwind uwtable }\n";
    out << "\n";
}

} // namespace Codegen
} // namespace Backends
} // namespace XXML
