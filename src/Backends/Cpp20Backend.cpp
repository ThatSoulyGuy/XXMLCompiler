#include "Backends/Cpp20Backend.h"
#include "Core/CompilationContext.h"
#include "Core/TypeRegistry.h"
#include "Core/OperatorRegistry.h"
#include "Core/FormatCompat.h"  // Compatibility layer for std::format
#include "Semantic/SemanticAnalyzer.h"
#include <algorithm>
#include <sstream>
#include <ranges>

namespace XXML::Backends {

Cpp20Backend::Cpp20Backend(Core::CompilationContext* context)
    : BackendBase() {
    context_ = context;

    // Set capabilities
    addCapability(Core::BackendCapability::SmartPointers);
    addCapability(Core::BackendCapability::Templates);
    addCapability(Core::BackendCapability::Concepts);
    addCapability(Core::BackendCapability::Modules);
    addCapability(Core::BackendCapability::Ranges);
    addCapability(Core::BackendCapability::Exceptions);
    addCapability(Core::BackendCapability::RTTI);
    addCapability(Core::BackendCapability::ValueSemantics);
}

bool Cpp20Backend::supportsFeature(std::string_view feature) const {
    return feature == "smart_pointers" ||
           feature == "templates" ||
           feature == "concepts" ||
           feature == "ranges" ||
           feature == "coroutines" ||
           feature == "modules";
}

void Cpp20Backend::initialize(Core::CompilationContext& context) {
    context_ = &context;
    reset();
}

std::string Cpp20Backend::generate(Parser::Program& program) {
    output_.str("");
    output_.clear();

    // Generate preamble
    output_ << generatePreamble();

    // Generate template instantiations first
    generateTemplateInstantiations();

    // Generate user code
    program.accept(*this);

    return output_.str();
}

std::string Cpp20Backend::generateHeader(Parser::Program& program) {
    generatingDeclarationsOnly_ = true;
    generatingImplementationsOnly_ = false;

    output_.str("");
    output_.clear();

    output_ << generatePreamble();
    program.accept(*this);

    generatingDeclarationsOnly_ = false;
    return output_.str();
}

std::string Cpp20Backend::generateImplementation(Parser::Program& program) {
    generatingDeclarationsOnly_ = false;
    generatingImplementationsOnly_ = true;

    output_.str("");
    output_.clear();

    program.accept(*this);

    generatingImplementationsOnly_ = false;
    return output_.str();
}

std::string Cpp20Backend::generatePreamble() {
    std::stringstream preamble;

    if (config_.generateComments) {
        preamble << "// Generated by XXML Compiler v2.0 (C++20 Backend)\n";
        preamble << "// Do not edit this file manually\n";
        preamble << "//\n";
        preamble << "// Compilation settings:\n";
        preamble << std::format("//   C++ Standard: C++20\n");
        preamble << std::string("//   Optimizations: ") + std::string(config_.enableOptimizations ? "enabled" : "disabled") + "\n";
        preamble << "\n";
    }

    // Required includes
    for (const auto& include : getRequiredIncludes()) {
        preamble << std::string("#include <") + std::string(include) + ">\n";
    }

    preamble << "\n";
    return preamble.str();
}

std::vector<std::string> Cpp20Backend::getRequiredIncludes() const {
    return {
        "iostream",
        "string",
        "memory",
        "cstdint",
        "vector",
        "unordered_map",
        "functional",
        "ranges",      // C++20 ranges
        "concepts",    // C++20 concepts
        "format"       // C++20 format
    };
}

std::vector<std::string> Cpp20Backend::getRequiredLibraries() const {
    return {};  // C++ standard library is linked by default
}

std::string Cpp20Backend::convertType(std::string_view xxmlType) const {
    if (!context_) {
        return std::string(xxmlType);  // Fallback
    }

    // Handle template instantiations
    size_t templateStart = xxmlType.find('<');
    if (templateStart != std::string_view::npos && xxmlType.back() == '>') {
        // Check for NativeType<T>
        if (xxmlType.starts_with("NativeType<")) {
            // Extract the native type
            auto nativeType = xxmlType.substr(11, xxmlType.length() - 12);

            // Use registry to look up common native types
            std::string nativeStr{nativeType};
            if (nativeStr == "ptr") return "void*";
            if (nativeStr == "int64") return "int64_t";
            if (nativeStr == "int32") return "int32_t";
            if (nativeStr == "float") return "float";
            if (nativeStr == "double") return "double";
            if (nativeStr == "bool") return "bool";

            return "void*";  // Default for unknown native types
        }

        // It's a template instantiation - parse and mangle it
        std::string templateName{xxmlType.substr(0, templateStart)};
        std::string argsStr{xxmlType.substr(templateStart + 1, xxmlType.length() - templateStart - 2)};

        // Simple argument parsing
        std::vector<std::string> args;
        std::string currentArg;
        int angleDepth = 0;

        for (char c : argsStr) {
            if (c == '<') {
                angleDepth++;
                currentArg += c;
            } else if (c == '>') {
                angleDepth--;
                currentArg += c;
            } else if (c == ',' && angleDepth == 0) {
                if (!currentArg.empty()) {
                    // Trim whitespace using C++20 ranges
                    auto trimmed = currentArg
                        | std::views::drop_while([](char c) { return std::isspace(c); })
                        | std::views::reverse
                        | std::views::drop_while([](char c) { return std::isspace(c); })
                        | std::views::reverse;
                    args.push_back(std::string(trimmed.begin(), trimmed.end()));
                }
                currentArg.clear();
            } else {
                currentArg += c;
            }
        }

        // Add last argument
        if (!currentArg.empty()) {
            auto trimmed = currentArg
                | std::views::drop_while([](char c) { return std::isspace(c); })
                | std::views::reverse
                | std::views::drop_while([](char c) { return std::isspace(c); })
                | std::views::reverse;
            args.push_back(std::string(trimmed.begin(), trimmed.end()));
        }

        return mangleTemplateName(templateName, args);
    }

    // ✅ USE TYPE REGISTRY instead of hardcoded checks!
    const auto* typeInfo = context_->types().getTypeInfo(xxmlType);
    if (typeInfo) {
        return typeInfo->cppType;
    }

    // Fallback for user-defined types
    return std::string(xxmlType);
}

std::string Cpp20Backend::convertOwnership(std::string_view type,
                                          std::string_view ownershipIndicator) const {
    // Map XXML ownership indicators to C++ types
    if (ownershipIndicator == "^") {
        // Owned - use unique_ptr for non-primitives
        if (requiresSmartPointer(std::string(type), Parser::OwnershipType::Owned)) {
            return std::string("std::unique_ptr<") + convertType(type) + ">";
        }
        return std::string(convertType(type));
    } else if (ownershipIndicator == "&") {
        // Reference
        return convertType(type) + "&";
    } else if (ownershipIndicator == "%") {
        // Copy/value
        return std::string(convertType(type));
    }

    return std::string(convertType(type));
}

// Helper methods
void Cpp20Backend::writeLine(const std::string& line) {
    output_ << getIndent() << line << "\n";
}

void Cpp20Backend::write(const std::string& text) {
    output_ << text;
}

std::string Cpp20Backend::getOwnershipType(Parser::OwnershipType ownership,
                                          const std::string& typeName) {
    std::string cppType = convertType(typeName);

    // Special case: None/void
    if (typeName == "None") {
        return "void";
    }

    // ✅ USE TYPE REGISTRY to check if builtin
    bool isBuiltin = false;
    if (context_) {
        const auto* typeInfo = context_->types().getTypeInfo(typeName);
        isBuiltin = typeInfo && typeInfo->isBuiltin;
    }

    switch (ownership) {
        case Parser::OwnershipType::Owned:
            if (isBuiltin) {
                return cppType;  // Built-ins use value semantics
            } else {
                return std::string("std::unique_ptr<") + cppType + ">";
            }

        case Parser::OwnershipType::Reference:
            return cppType + "&";

        case Parser::OwnershipType::Copy:
            return cppType;  // Pass by value

        default:
            return cppType;
    }
}

std::string Cpp20Backend::getParameterType(Parser::OwnershipType ownership,
                                          const std::string& typeName) {
    std::string cppType = convertType(typeName);

    // ✅ USE TYPE REGISTRY
    bool isBuiltin = false;
    if (context_) {
        const auto* typeInfo = context_->types().getTypeInfo(typeName);
        isBuiltin = typeInfo && typeInfo->isBuiltin;
    }

    switch (ownership) {
        case Parser::OwnershipType::Owned:
            if (isBuiltin) {
                return cppType;
            } else {
                return std::string("std::unique_ptr<") + cppType + ">";
            }

        case Parser::OwnershipType::Reference:
            return cppType + "&";

        case Parser::OwnershipType::Copy:
            // Optimization: use const reference for strings
            if (typeName == "String") {
                return std::string("const ") + cppType + "&";
            }
            return cppType;

        default:
            return cppType;
    }
}

bool Cpp20Backend::requiresSmartPointer(const std::string& typeName,
                                       Parser::OwnershipType ownership) const {
    // Only owned types that are not built-in require smart pointers
    if (ownership != Parser::OwnershipType::Owned) {
        return false;
    }

    // ✅ USE TYPE REGISTRY
    if (context_) {
        const auto* typeInfo = context_->types().getTypeInfo(typeName);
        return typeInfo && !typeInfo->isBuiltin && typeName != "None";
    }

    return false;  // Conservative fallback
}

std::string Cpp20Backend::sanitizeIdentifier(const std::string& name) {
    std::string sanitized = name;

    // Remove angle brackets
    std::erase(sanitized, '<');
    std::erase(sanitized, '>');

    // Handle C++ keywords
    if (sanitized == "and") return "and_";
    if (sanitized == "or") return "or_";
    if (sanitized == "not") return "not_";
    if (sanitized == "xor") return "xor_";

    return sanitized;
}

// Template code generation (simplified - full implementation would be larger)
std::string Cpp20Backend::mangleTemplateName(const std::string& templateName,
                                            const std::vector<std::string>& args) const {
    std::string mangled = templateName;

    for (const auto& arg : args) {
        mangled += "_" + arg;
    }

    return mangled;
}

void Cpp20Backend::generateTemplateInstantiations() {
    // Template instantiation logic would go here
    // For now, placeholder
}

std::unique_ptr<Parser::ClassDecl> Cpp20Backend::cloneClassDecl(Parser::ClassDecl* original) {
    // Simplified clone - full implementation would deep copy all members
    auto clone = std::make_unique<Parser::ClassDecl>(
        original->name,
        original->templateParams,
        original->isFinal,
        original->baseClass,
        original->location
    );
    return clone;
}

void Cpp20Backend::substituteTypes(Parser::ClassDecl* classDecl,
                                  const std::unordered_map<std::string, std::string>& typeMap) {
    // Type substitution logic for templates
    // Full implementation would be more complex
}

void Cpp20Backend::substituteTypesInTypeRef(Parser::TypeRef* typeRef,
                                          const std::unordered_map<std::string, std::string>& typeMap) {
    // Substitute types in type references
}

void Cpp20Backend::substituteTypesInStatement(Parser::Statement* stmt,
                                            const std::unordered_map<std::string, std::string>& typeMap) {
    // Substitute types in statements
}

void Cpp20Backend::substituteTypesInExpression(Parser::Expression* expr,
                                             const std::unordered_map<std::string, std::string>& typeMap) {
    // Substitute types in expressions
}

// Visitor implementations - Program and declarations
void Cpp20Backend::visit(Parser::Program& node) {
    for (auto& decl : node.declarations) {
        decl->accept(*this);
    }
}

void Cpp20Backend::visit(Parser::ImportDecl& node) {
    if (config_.generateComments) {
        writeLine(std::string("// Import: ") + node.modulePath);
    }
}

void Cpp20Backend::visit(Parser::NamespaceDecl& node) {
    std::string previousNamespace = currentNamespace_;
    if (!currentNamespace_.empty()) {
        currentNamespace_ += "::";
    }
    currentNamespace_ += node.name;

    writeLine(std::string("namespace ") + sanitizeIdentifier(node.name) + " {{");
    writeLine("");
    indent();

    for (auto& decl : node.declarations) {
        decl->accept(*this);
    }

    dedent();
    writeLine(std::string("}} // namespace ") + sanitizeIdentifier(node.name));
    writeLine("");

    currentNamespace_ = previousNamespace;
}

void Cpp20Backend::visit(Parser::ClassDecl& node) {
    // Skip template class definitions
    if (!node.templateParams.empty()) {
        return;
    }

    currentClassName_ = node.name;

    if (generatingImplementationsOnly_) {
        inClassDefinition_ = false;
        for (auto& section : node.sections) {
            section->accept(*this);
        }
        return;
    }

    inClassDefinition_ = true;
    std::string className = sanitizeIdentifier(node.name);

    output_ << getIndent() << "class " << className;

    if (!node.baseClass.empty() && node.baseClass != "None") {
        output_ << " : public " << convertType(node.baseClass);
    }

    output_ << " {\n";
    indent();

    for (auto& section : node.sections) {
        section->accept(*this);
    }

    dedent();
    writeLine("};");
    writeLine("");

    inClassDefinition_ = false;
}

void Cpp20Backend::visit(Parser::AccessSection& node) {
    if (!generatingImplementationsOnly_) {
        switch (node.modifier) {
            case Parser::AccessModifier::Public:
                writeLine("public:");
                break;
            case Parser::AccessModifier::Private:
                writeLine("private:");
                break;
            case Parser::AccessModifier::Protected:
                writeLine("protected:");
                break;
        }
        indent();
    }

    for (auto& decl : node.declarations) {
        decl->accept(*this);
    }

    if (!generatingImplementationsOnly_) {
        dedent();
    }
}

void Cpp20Backend::visit(Parser::PropertyDecl& node) {
    if (generatingImplementationsOnly_) {
        return;
    }

    std::string propertyName = sanitizeIdentifier(node.name);
    std::string type = getOwnershipType(node.type->ownership, node.type->typeName);

    writeLine(type + propertyName + ";");
}

void Cpp20Backend::visit(Parser::ConstructorDecl& node) {
    if (generatingImplementationsOnly_) {
        return;
    }

    if (node.isDefault) {
        writeLine(currentClassName_ + std::string("() = default;"));
    } else {
        output_ << getIndent() << currentClassName_ << "(";

        for (size_t i = 0; i < node.parameters.size(); ++i) {
            if (i > 0) output_ << ", ";
            auto& param = node.parameters[i];
            output_ << getOwnershipType(param->type->ownership, param->type->typeName)
                   << " " << sanitizeIdentifier(param->name);
        }

        output_ << ") {\n";
        indent();

        for (auto& stmt : node.body) {
            stmt->accept(*this);
        }

        dedent();
        writeLine("}");
    }
}

// Continue with remaining visitor methods in next part due to size...
// For now, let me create stubs for the remaining methods

void Cpp20Backend::visit(Parser::MethodDecl& node) {
    // Method implementation (complex - would need full implementation)
    // For now, basic structure
    std::string methodName = sanitizeIdentifier(node.name);
    std::string returnType = getOwnershipType(node.returnType->ownership, node.returnType->typeName);

    output_ << getIndent() << returnType << " " << methodName << "(";

    for (size_t i = 0; i < node.parameters.size(); ++i) {
        if (i > 0) output_ << ", ";
        auto& param = node.parameters[i];
        output_ << getParameterType(param->type->ownership, param->type->typeName)
               << " " << sanitizeIdentifier(param->name);
    }

    output_ << ") {\n";
    indent();

    for (auto& stmt : node.body) {
        stmt->accept(*this);
    }

    dedent();
    writeLine("}");
}

void Cpp20Backend::visit(Parser::ParameterDecl& node) {}

void Cpp20Backend::visit(Parser::EntrypointDecl& node) {
    writeLine("int main() {");
    indent();

    for (auto& stmt : node.body) {
        stmt->accept(*this);
    }

    dedent();
    writeLine("}");
    writeLine("");
}

// Statement visitors
void Cpp20Backend::visit(Parser::InstantiateStmt& node) {
    std::string varName = sanitizeIdentifier(node.variableName);
    std::string type = getOwnershipType(node.type->ownership, node.type->typeName);

    output_ << getIndent() << type << " " << varName << " = ";

    bool isSmartPtr = requiresSmartPointer(node.type->typeName, node.type->ownership);
    variableIsSmartPointer_[node.variableName] = isSmartPtr;

    node.initializer->accept(*this);
    output_ << ";\n";
}

void Cpp20Backend::visit(Parser::RunStmt& node) {
    output_ << getIndent();
    node.expression->accept(*this);
    output_ << ";\n";
}

void Cpp20Backend::visit(Parser::ForStmt& node) {
    output_ << getIndent() << "for (";

    std::string iteratorType = convertType(node.iteratorType->typeName);
    std::string iteratorName = sanitizeIdentifier(node.iteratorName);

    output_ << iteratorType << " " << iteratorName << " = ";
    node.rangeStart->accept(*this);
    output_ << "; " << iteratorName << " < ";
    node.rangeEnd->accept(*this);
    output_ << "; ++" << iteratorName << ") {\n";

    indent();
    for (auto& stmt : node.body) {
        stmt->accept(*this);
    }
    dedent();

    writeLine("}");
}

void Cpp20Backend::visit(Parser::ExitStmt& node) {
    writeLine("std::exit(0);");
}

void Cpp20Backend::visit(Parser::ReturnStmt& node) {
    output_ << getIndent() << "return ";
    if (node.value) {
        node.value->accept(*this);
    }
    output_ << ";\n";
}

void Cpp20Backend::visit(Parser::IfStmt& node) {
    output_ << getIndent() << "if (";
    node.condition->accept(*this);
    output_ << ") {\n";

    indent();
    for (auto& stmt : node.thenBranch) {
        stmt->accept(*this);
    }
    dedent();

    if (!node.elseBranch.empty()) {
        writeLine("} else {");
        indent();
        for (auto& stmt : node.elseBranch) {
            stmt->accept(*this);
        }
        dedent();
    }

    writeLine("}");
}

void Cpp20Backend::visit(Parser::WhileStmt& node) {
    output_ << getIndent() << "while (";
    node.condition->accept(*this);
    output_ << ") {\n";

    indent();
    for (auto& stmt : node.body) {
        stmt->accept(*this);
    }
    dedent();

    writeLine("}");
}

void Cpp20Backend::visit(Parser::BreakStmt& node) {
    writeLine("break;");
}

void Cpp20Backend::visit(Parser::ContinueStmt& node) {
    writeLine("continue;");
}

// Expression visitors
void Cpp20Backend::visit(Parser::IntegerLiteralExpr& node) {
    output_ << std::string("Integer(") + std::to_string(node.value) + ")";
}

void Cpp20Backend::visit(Parser::StringLiteralExpr& node) {
    output_ << std::string("String(\"") + node.value + "\")";
}

void Cpp20Backend::visit(Parser::BoolLiteralExpr& node) {
    output_ << std::string("Bool(") + (node.value ? "true" : "false") + ")";
}

void Cpp20Backend::visit(Parser::ThisExpr& node) {
    output_ << "this";
}

void Cpp20Backend::visit(Parser::IdentifierExpr& node) {
    output_ << sanitizeIdentifier(node.name);
}

void Cpp20Backend::visit(Parser::ReferenceExpr& node) {
    output_ << "&";
    node.expr->accept(*this);
}

void Cpp20Backend::visit(Parser::MemberAccessExpr& node) {
    node.object->accept(*this);

    bool useArrow = false;
    if (auto* id = dynamic_cast<Parser::IdentifierExpr*>(node.object.get())) {
        useArrow = variableIsSmartPointer_[id->name];
    }

    output_ << (useArrow ? "->" : ".") << sanitizeIdentifier(node.member);
}

void Cpp20Backend::visit(Parser::CallExpr& node) {
    node.callee->accept(*this);
    output_ << "(";

    for (size_t i = 0; i < node.arguments.size(); ++i) {
        if (i > 0) output_ << ", ";
        node.arguments[i]->accept(*this);
    }

    output_ << ")";
}

void Cpp20Backend::visit(Parser::BinaryExpr& node) {
    // ✅ USE OPERATOR REGISTRY for code generation!
    if (context_) {
        node.left->accept(*this);
        std::string leftCode = output_.str();
        output_.str("");

        node.right->accept(*this);
        std::string rightCode = output_.str();
        output_.str("");

        std::string result = context_->operators().generateBinaryCpp(node.op, leftCode, rightCode);
        output_ << result;
    } else {
        // Fallback
        output_ << "(";
        node.left->accept(*this);
        output_ << " " << node.op << " ";
        node.right->accept(*this);
        output_ << ")";
    }
}

void Cpp20Backend::visit(Parser::TypeRef& node) {
    output_ << convertType(node.typeName);
}

} // namespace XXML::Backends
