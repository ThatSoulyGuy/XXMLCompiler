#include "Backends/Cpp20Backend.h"
#include "Core/CompilationContext.h"
#include "Core/TypeRegistry.h"
#include "Core/OperatorRegistry.h"
#include "Core/FormatCompat.h"  // Compatibility layer for std::format
#include "Semantic/SemanticAnalyzer.h"
#include <algorithm>
#include <sstream>
#include <ranges>

namespace XXML::Backends {

Cpp20Backend::Cpp20Backend(Core::CompilationContext* context)
    : BackendBase() {
    context_ = context;

    // Set capabilities
    addCapability(Core::BackendCapability::SmartPointers);
    addCapability(Core::BackendCapability::Templates);
    addCapability(Core::BackendCapability::Concepts);
    addCapability(Core::BackendCapability::Modules);
    addCapability(Core::BackendCapability::Ranges);
    addCapability(Core::BackendCapability::Exceptions);
    addCapability(Core::BackendCapability::RTTI);
    addCapability(Core::BackendCapability::ValueSemantics);
}

bool Cpp20Backend::supportsFeature(std::string_view feature) const {
    return feature == "smart_pointers" ||
           feature == "templates" ||
           feature == "concepts" ||
           feature == "ranges" ||
           feature == "coroutines" ||
           feature == "modules";
}

void Cpp20Backend::initialize(Core::CompilationContext& context) {
    context_ = &context;
    reset();
}

std::string Cpp20Backend::generate(Parser::Program& program) {
    output_.str("");
    output_.clear();

    // Generate preamble
    output_ << generatePreamble();

    // Generate template instantiations first
    generateTemplateInstantiations();

    // Generate user code
    program.accept(*this);

    return output_.str();
}

std::string Cpp20Backend::generateHeader(Parser::Program& program) {
    generatingDeclarationsOnly_ = true;
    generatingImplementationsOnly_ = false;

    output_.str("");
    output_.clear();

    output_ << generatePreamble();
    program.accept(*this);

    generatingDeclarationsOnly_ = false;
    return output_.str();
}

std::string Cpp20Backend::generateImplementation(Parser::Program& program) {
    generatingDeclarationsOnly_ = false;
    generatingImplementationsOnly_ = true;

    output_.str("");
    output_.clear();

    program.accept(*this);

    generatingImplementationsOnly_ = false;
    return output_.str();
}

std::string Cpp20Backend::generatePreamble() {
    std::stringstream preamble;

    if (config_.generateComments) {
        preamble << "// Generated by XXML Compiler v2.0 (C++20 Backend)\n";
        preamble << "// Do not edit this file manually\n";
        preamble << "//\n";
        preamble << "// Compilation settings:\n";
        preamble << std::format("//   C++ Standard: C++20\n");
        preamble << std::string("//   Optimizations: ") + std::string(config_.enableOptimizations ? "enabled" : "disabled") + "\n";
        preamble << "\n";
    }

    // Required includes
    for (const auto& include : getRequiredIncludes()) {
        preamble << std::string("#include <") + std::string(include) + ">\n";
    }

    preamble << "\n";
    return preamble.str();
}

std::vector<std::string> Cpp20Backend::getRequiredIncludes() const {
    return {
        "iostream",
        "string",
        "memory",
        "cstdint",
        "vector",
        "unordered_map",
        "functional",
        "ranges",      // C++20 ranges
        "concepts",    // C++20 concepts
        "format"       // C++20 format
    };
}

std::vector<std::string> Cpp20Backend::getRequiredLibraries() const {
    return {};  // C++ standard library is linked by default
}

std::string Cpp20Backend::convertType(std::string_view xxmlType) const {
    if (!context_) {
        return std::string(xxmlType);  // Fallback
    }

    // Handle template instantiations
    size_t templateStart = xxmlType.find('<');
    if (templateStart != std::string_view::npos && xxmlType.back() == '>') {
        // Check for NativeType<T>
        if (xxmlType.starts_with("NativeType<")) {
            // Extract the native type
            auto nativeType = xxmlType.substr(11, xxmlType.length() - 12);

            // Use registry to look up common native types
            std::string nativeStr{nativeType};
            if (nativeStr == "ptr") return "void*";
            if (nativeStr == "int64") return "int64_t";
            if (nativeStr == "int32") return "int32_t";
            if (nativeStr == "float") return "float";
            if (nativeStr == "double") return "double";
            if (nativeStr == "bool") return "bool";

            return "void*";  // Default for unknown native types
        }

        // It's a template instantiation - parse and mangle it
        std::string templateName{xxmlType.substr(0, templateStart)};
        std::string argsStr{xxmlType.substr(templateStart + 1, xxmlType.length() - templateStart - 2)};

        // Simple argument parsing
        std::vector<std::string> args;
        std::string currentArg;
        int angleDepth = 0;

        for (char c : argsStr) {
            if (c == '<') {
                angleDepth++;
                currentArg += c;
            } else if (c == '>') {
                angleDepth--;
                currentArg += c;
            } else if (c == ',' && angleDepth == 0) {
                if (!currentArg.empty()) {
                    // Trim whitespace using C++20 ranges
                    auto trimmed = currentArg
                        | std::views::drop_while([](char c) { return std::isspace(c); })
                        | std::views::reverse
                        | std::views::drop_while([](char c) { return std::isspace(c); })
                        | std::views::reverse;
                    args.push_back(std::string(trimmed.begin(), trimmed.end()));
                }
                currentArg.clear();
            } else {
                currentArg += c;
            }
        }

        // Add last argument
        if (!currentArg.empty()) {
            auto trimmed = currentArg
                | std::views::drop_while([](char c) { return std::isspace(c); })
                | std::views::reverse
                | std::views::drop_while([](char c) { return std::isspace(c); })
                | std::views::reverse;
            args.push_back(std::string(trimmed.begin(), trimmed.end()));
        }

        return mangleTemplateName(templateName, args);
    }

    // ✅ USE TYPE REGISTRY instead of hardcoded checks!
    const auto* typeInfo = context_->types().getTypeInfo(xxmlType);
    if (typeInfo) {
        return typeInfo->cppType;
    }

    // Fallback for user-defined types
    return std::string(xxmlType);
}

std::string Cpp20Backend::convertOwnership(std::string_view type,
                                          std::string_view ownershipIndicator) const {
    // Map XXML ownership indicators to C++ types
    if (ownershipIndicator == "^") {
        // Owned - use unique_ptr for non-primitives
        if (requiresSmartPointer(std::string(type), Parser::OwnershipType::Owned)) {
            return std::string("std::unique_ptr<") + convertType(type) + ">";
        }
        return std::string(convertType(type));
    } else if (ownershipIndicator == "&") {
        // Reference
        return convertType(type) + "&";
    } else if (ownershipIndicator == "%") {
        // Copy/value
        return std::string(convertType(type));
    }

    return std::string(convertType(type));
}

// Helper methods
void Cpp20Backend::writeLine(const std::string& line) {
    output_ << getIndent() << line << "\n";
}

void Cpp20Backend::write(const std::string& text) {
    output_ << text;
}

std::string Cpp20Backend::getOwnershipType(Parser::OwnershipType ownership,
                                          const std::string& typeName) {
    std::string cppType = convertType(typeName);

    // Special case: None/void
    if (typeName == "None") {
        return "void";
    }

    // ✅ USE TYPE REGISTRY to check if builtin
    bool isBuiltin = false;
    if (context_) {
        const auto* typeInfo = context_->types().getTypeInfo(typeName);
        isBuiltin = typeInfo && typeInfo->isBuiltin;
    }

    switch (ownership) {
        case Parser::OwnershipType::Owned:
            if (isBuiltin) {
                return cppType;  // Built-ins use value semantics
            } else {
                return std::string("std::unique_ptr<") + cppType + ">";
            }

        case Parser::OwnershipType::Reference:
            return cppType + "&";

        case Parser::OwnershipType::Copy:
            return cppType;  // Pass by value

        default:
            return cppType;
    }
}

std::string Cpp20Backend::getParameterType(Parser::OwnershipType ownership,
                                          const std::string& typeName) {
    std::string cppType = convertType(typeName);

    // ✅ USE TYPE REGISTRY
    bool isBuiltin = false;
    if (context_) {
        const auto* typeInfo = context_->types().getTypeInfo(typeName);
        isBuiltin = typeInfo && typeInfo->isBuiltin;
    }

    switch (ownership) {
        case Parser::OwnershipType::Owned:
            if (isBuiltin) {
                return cppType;
            } else {
                return std::string("std::unique_ptr<") + cppType + ">";
            }

        case Parser::OwnershipType::Reference:
            return cppType + "&";

        case Parser::OwnershipType::Copy:
            // Optimization: use const reference for strings
            if (typeName == "String") {
                return std::string("const ") + cppType + "&";
            }
            return cppType;

        default:
            return cppType;
    }
}

bool Cpp20Backend::requiresSmartPointer(const std::string& typeName,
                                       Parser::OwnershipType ownership) const {
    // Only owned types that are not built-in require smart pointers
    if (ownership != Parser::OwnershipType::Owned) {
        return false;
    }

    // ✅ USE TYPE REGISTRY
    if (context_) {
        const auto* typeInfo = context_->types().getTypeInfo(typeName);
        return typeInfo && !typeInfo->isBuiltin && typeName != "None";
    }

    return false;  // Conservative fallback
}

std::string Cpp20Backend::sanitizeIdentifier(const std::string& name) {
    std::string sanitized = name;

    // Remove angle brackets
    std::erase(sanitized, '<');
    std::erase(sanitized, '>');

    // Handle C++ keywords
    if (sanitized == "and") return "and_";
    if (sanitized == "or") return "or_";
    if (sanitized == "not") return "not_";
    if (sanitized == "xor") return "xor_";

    return sanitized;
}

// Template code generation (simplified - full implementation would be larger)
std::string Cpp20Backend::mangleTemplateName(const std::string& templateName,
                                            const std::vector<std::string>& args) const {
    std::string mangled = templateName;

    for (const auto& arg : args) {
        mangled += "_" + arg;
    }

    return mangled;
}

void Cpp20Backend::generateTemplateInstantiations() {
    if (!semanticAnalyzer_) {
        return; // No semantic analyzer, skip template generation
    }

    const auto& instantiations = semanticAnalyzer_->getTemplateInstantiations();
    const auto& templateClasses = semanticAnalyzer_->getTemplateClasses();

    for (const auto& inst : instantiations) {
        auto it = templateClasses.find(inst.templateName);
        if (it == templateClasses.end()) {
            continue; // Template class not found, skip
        }

        Parser::ClassDecl* templateClass = it->second;

        // Generate mangled class name
        std::string mangledName = inst.templateName;
        size_t valueIndex = 0;
        for (const auto& arg : inst.arguments) {
            if (arg.kind == Parser::TemplateArgument::Kind::Type) {
                mangledName += "_" + arg.typeArg;
            } else {
                // Use evaluated value for non-type parameters
                if (valueIndex < inst.evaluatedValues.size()) {
                    mangledName += "_" + std::to_string(inst.evaluatedValues[valueIndex]);
                    valueIndex++;
                }
            }
        }

        // Build type substitution map (template params -> concrete types/values)
        std::unordered_map<std::string, std::string> typeMap;
        valueIndex = 0;
        for (size_t i = 0; i < templateClass->templateParams.size() && i < inst.arguments.size(); ++i) {
            const auto& param = templateClass->templateParams[i];
            const auto& arg = inst.arguments[i];

            if (param.kind == Parser::TemplateParameter::Kind::Type) {
                if (arg.kind == Parser::TemplateArgument::Kind::Type) {
                    typeMap[param.name] = arg.typeArg;
                }
            } else {
                // Non-type parameter - substitute with the evaluated constant
                if (valueIndex < inst.evaluatedValues.size()) {
                    typeMap[param.name] = std::to_string(inst.evaluatedValues[valueIndex]);
                    valueIndex++;
                }
            }
        }

        // Clone the template class and substitute types
        auto instantiated = cloneAndSubstituteClassDecl(templateClass, mangledName, typeMap);

        // Generate code for the instantiated class
        if (instantiated) {
            instantiated->accept(*this);
        }
    }
}

std::unique_ptr<Parser::ClassDecl> Cpp20Backend::cloneClassDecl(Parser::ClassDecl* original) {
    // Simplified clone - full implementation would deep copy all members
    auto clone = std::make_unique<Parser::ClassDecl>(
        original->name,
        original->templateParams,
        original->isFinal,
        original->baseClass,
        original->location
    );
    return clone;
}

std::unique_ptr<Parser::ClassDecl> Cpp20Backend::cloneAndSubstituteClassDecl(
    Parser::ClassDecl* original,
    const std::string& newName,
    const std::unordered_map<std::string, std::string>& typeMap) {

    // Create new class with mangled name and no template parameters
    auto instantiated = std::make_unique<Parser::ClassDecl>(
        newName,
        std::vector<Parser::TemplateParameter>{},  // No template params
        original->isFinal,
        original->baseClass,
        original->location
    );

    // Deep clone all sections
    for (const auto& section : original->sections) {
        auto newSection = std::make_unique<Parser::AccessSection>(
            section->modifier,
            section->location
        );

        // Clone all declarations in the section
        for (const auto& decl : section->declarations) {
            if (auto* prop = dynamic_cast<Parser::PropertyDecl*>(decl.get())) {
                auto clonedType = cloneTypeRef(prop->type.get(), typeMap);
                auto clonedProp = std::make_unique<Parser::PropertyDecl>(
                    prop->name,
                    std::move(clonedType),
                    prop->location
                );
                newSection->declarations.push_back(std::move(clonedProp));
            }
            else if (auto* ctor = dynamic_cast<Parser::ConstructorDecl*>(decl.get())) {
                // Clone constructor (simplified - copy structure)
                std::vector<std::unique_ptr<Parser::ParameterDecl>> clonedParams;
                for (const auto& param : ctor->parameters) {
                    auto clonedType = cloneTypeRef(param->type.get(), typeMap);
                    auto clonedParam = std::make_unique<Parser::ParameterDecl>(
                        param->name,
                        std::move(clonedType),
                        param->location
                    );
                    clonedParams.push_back(std::move(clonedParam));
                }

                std::vector<std::unique_ptr<Parser::Statement>> clonedBody;
                for (const auto& stmt : ctor->body) {
                    auto clonedStmt = cloneStatement(stmt.get(), typeMap);
                    if (clonedStmt) clonedBody.push_back(std::move(clonedStmt));
                }

                auto clonedCtor = std::make_unique<Parser::ConstructorDecl>(
                    ctor->isDefault,
                    std::move(clonedParams),
                    std::move(clonedBody),
                    ctor->location
                );
                newSection->declarations.push_back(std::move(clonedCtor));
            }
            else if (auto* method = dynamic_cast<Parser::MethodDecl*>(decl.get())) {
                // Clone method with type substitution
                auto clonedRetType = cloneTypeRef(method->returnType.get(), typeMap);

                std::vector<std::unique_ptr<Parser::ParameterDecl>> clonedParams;
                for (const auto& param : method->parameters) {
                    auto clonedType = cloneTypeRef(param->type.get(), typeMap);
                    auto clonedParam = std::make_unique<Parser::ParameterDecl>(
                        param->name,
                        std::move(clonedType),
                        param->location
                    );
                    clonedParams.push_back(std::move(clonedParam));
                }

                std::vector<std::unique_ptr<Parser::Statement>> clonedBody;
                for (const auto& stmt : method->body) {
                    auto clonedStmt = cloneStatement(stmt.get(), typeMap);
                    if (clonedStmt) clonedBody.push_back(std::move(clonedStmt));
                }

                auto clonedMethod = std::make_unique<Parser::MethodDecl>(
                    method->name,
                    std::move(clonedRetType),
                    std::move(clonedParams),
                    std::move(clonedBody),
                    method->location
                );
                newSection->declarations.push_back(std::move(clonedMethod));
            }
        }

        instantiated->sections.push_back(std::move(newSection));
    }

    return instantiated;
}

// Implement cloning helper methods
std::unique_ptr<Parser::TypeRef> Cpp20Backend::cloneTypeRef(Parser::TypeRef* original,
                                                             const std::unordered_map<std::string, std::string>& typeMap) {
    if (!original) return nullptr;

    // Substitute type name if it's a template parameter
    std::string typeName = original->typeName;
    auto it = typeMap.find(typeName);
    if (it != typeMap.end()) {
        typeName = it->second;
    }

    // Clone template arguments
    std::vector<Parser::TemplateArgument> clonedArgs;
    for (const auto& arg : original->templateArgs) {
        if (arg.kind == Parser::TemplateArgument::Kind::Type) {
            // Type argument - substitute if it's a template parameter
            std::string argType = arg.typeArg;
            auto argIt = typeMap.find(argType);
            if (argIt != typeMap.end()) {
                argType = argIt->second;
            }
            clonedArgs.emplace_back(argType, arg.location);
        } else {
            // Value argument - clone the expression
            auto clonedExpr = cloneExpression(arg.valueArg.get(), typeMap);
            clonedArgs.emplace_back(std::move(clonedExpr), arg.location);
        }
    }

    return std::make_unique<Parser::TypeRef>(typeName, std::move(clonedArgs), original->ownership, original->location);
}

std::unique_ptr<Parser::Statement> Cpp20Backend::cloneStatement(Parser::Statement* stmt,
                                                                 const std::unordered_map<std::string, std::string>& typeMap) {
    if (!stmt) return nullptr;

    // Simplified statement cloning - handle the most common cases
    if (auto* inst = dynamic_cast<Parser::InstantiateStmt*>(stmt)) {
        auto clonedType = cloneTypeRef(inst->type.get(), typeMap);
        auto clonedInit = cloneExpression(inst->initializer.get(), typeMap);
        return std::make_unique<Parser::InstantiateStmt>(
            std::move(clonedType),
            inst->variableName,
            std::move(clonedInit),
            inst->location
        );
    }
    if (auto* run = dynamic_cast<Parser::RunStmt*>(stmt)) {
        auto clonedExpr = cloneExpression(run->expression.get(), typeMap);
        return std::make_unique<Parser::RunStmt>(std::move(clonedExpr), run->location);
    }
    if (auto* ret = dynamic_cast<Parser::ReturnStmt*>(stmt)) {
        auto clonedExpr = ret->value ? cloneExpression(ret->value.get(), typeMap) : nullptr;
        return std::make_unique<Parser::ReturnStmt>(std::move(clonedExpr), ret->location);
    }

    // For other statement types, return nullptr (placeholder)
    return nullptr;
}

std::unique_ptr<Parser::Expression> Cpp20Backend::cloneExpression(Parser::Expression* expr,
                                                                   const std::unordered_map<std::string, std::string>& typeMap) {
    if (!expr) return nullptr;

    // Clone various expression types
    if (auto* intLit = dynamic_cast<Parser::IntegerLiteralExpr*>(expr)) {
        return std::make_unique<Parser::IntegerLiteralExpr>(intLit->value, intLit->location);
    }
    if (auto* strLit = dynamic_cast<Parser::StringLiteralExpr*>(expr)) {
        return std::make_unique<Parser::StringLiteralExpr>(strLit->value, strLit->location);
    }
    if (auto* boolLit = dynamic_cast<Parser::BoolLiteralExpr*>(expr)) {
        return std::make_unique<Parser::BoolLiteralExpr>(boolLit->value, boolLit->location);
    }
    if (auto* ident = dynamic_cast<Parser::IdentifierExpr*>(expr)) {
        // Check if identifier references a non-type template parameter
        std::string name = ident->name;
        auto it = typeMap.find(name);
        if (it != typeMap.end()) {
            // Replace with the substituted value (as integer literal if possible)
            try {
                int64_t value = std::stoll(it->second);
                return std::make_unique<Parser::IntegerLiteralExpr>(value, ident->location);
            } catch (...) {
                // Not a number, keep as identifier with substituted name
                return std::make_unique<Parser::IdentifierExpr>(it->second, ident->location);
            }
        }
        return std::make_unique<Parser::IdentifierExpr>(name, ident->location);
    }
    if (auto* binExpr = dynamic_cast<Parser::BinaryExpr*>(expr)) {
        auto clonedLeft = cloneExpression(binExpr->left.get(), typeMap);
        auto clonedRight = cloneExpression(binExpr->right.get(), typeMap);
        return std::make_unique<Parser::BinaryExpr>(
            std::move(clonedLeft),
            binExpr->op,
            std::move(clonedRight),
            binExpr->location
        );
    }
    if (auto* callExpr = dynamic_cast<Parser::CallExpr*>(expr)) {
        auto clonedCallee = cloneExpression(callExpr->callee.get(), typeMap);
        std::vector<std::unique_ptr<Parser::Expression>> clonedArgs;
        for (const auto& arg : callExpr->arguments) {
            clonedArgs.push_back(cloneExpression(arg.get(), typeMap));
        }
        return std::make_unique<Parser::CallExpr>(
            std::move(clonedCallee),
            std::move(clonedArgs),
            callExpr->location
        );
    }

    // For other expression types, return nullptr (placeholder)
    return nullptr;
}

void Cpp20Backend::substituteTypes(Parser::ClassDecl* classDecl,
                                  const std::unordered_map<std::string, std::string>& typeMap) {
    // Type substitution logic for templates
    // Full implementation would be more complex
}

void Cpp20Backend::substituteTypesInTypeRef(Parser::TypeRef* typeRef,
                                          const std::unordered_map<std::string, std::string>& typeMap) {
    // Substitute types in type references
}

void Cpp20Backend::substituteTypesInStatement(Parser::Statement* stmt,
                                            const std::unordered_map<std::string, std::string>& typeMap) {
    // Substitute types in statements
}

void Cpp20Backend::substituteTypesInExpression(Parser::Expression* expr,
                                             const std::unordered_map<std::string, std::string>& typeMap) {
    // Substitute types in expressions
}

// Visitor implementations - Program and declarations
void Cpp20Backend::visit(Parser::Program& node) {
    for (auto& decl : node.declarations) {
        decl->accept(*this);
    }
}

void Cpp20Backend::visit(Parser::ImportDecl& node) {
    if (config_.generateComments) {
        writeLine(std::string("// Import: ") + node.modulePath);
    }
}

void Cpp20Backend::visit(Parser::NamespaceDecl& node) {
    std::string previousNamespace = currentNamespace_;
    if (!currentNamespace_.empty()) {
        currentNamespace_ += "::";
    }
    currentNamespace_ += node.name;

    writeLine(std::string("namespace ") + sanitizeIdentifier(node.name) + " {{");
    writeLine("");
    indent();

    for (auto& decl : node.declarations) {
        decl->accept(*this);
    }

    dedent();
    writeLine(std::string("}} // namespace ") + sanitizeIdentifier(node.name));
    writeLine("");

    currentNamespace_ = previousNamespace;
}

void Cpp20Backend::visit(Parser::ClassDecl& node) {
    // Skip template class definitions
    if (!node.templateParams.empty()) {
        return;
    }

    currentClassName_ = node.name;

    if (generatingImplementationsOnly_) {
        inClassDefinition_ = false;
        for (auto& section : node.sections) {
            section->accept(*this);
        }
        return;
    }

    inClassDefinition_ = true;
    std::string className = sanitizeIdentifier(node.name);

    output_ << getIndent() << "class " << className;

    if (!node.baseClass.empty() && node.baseClass != "None") {
        output_ << " : public " << convertType(node.baseClass);
    }

    output_ << " {\n";
    indent();

    for (auto& section : node.sections) {
        section->accept(*this);
    }

    dedent();
    writeLine("};");
    writeLine("");

    inClassDefinition_ = false;
}

void Cpp20Backend::visit(Parser::AccessSection& node) {
    if (!generatingImplementationsOnly_) {
        switch (node.modifier) {
            case Parser::AccessModifier::Public:
                writeLine("public:");
                break;
            case Parser::AccessModifier::Private:
                writeLine("private:");
                break;
            case Parser::AccessModifier::Protected:
                writeLine("protected:");
                break;
        }
        indent();
    }

    for (auto& decl : node.declarations) {
        decl->accept(*this);
    }

    if (!generatingImplementationsOnly_) {
        dedent();
    }
}

void Cpp20Backend::visit(Parser::PropertyDecl& node) {
    if (generatingImplementationsOnly_) {
        return;
    }

    std::string propertyName = sanitizeIdentifier(node.name);
    std::string type = getOwnershipType(node.type->ownership, node.type->typeName);

    writeLine(type + propertyName + ";");
}

void Cpp20Backend::visit(Parser::ConstructorDecl& node) {
    if (generatingImplementationsOnly_) {
        return;
    }

    if (node.isDefault) {
        writeLine(currentClassName_ + std::string("() = default;"));
    } else {
        output_ << getIndent() << currentClassName_ << "(";

        for (size_t i = 0; i < node.parameters.size(); ++i) {
            if (i > 0) output_ << ", ";
            auto& param = node.parameters[i];
            output_ << getOwnershipType(param->type->ownership, param->type->typeName)
                   << " " << sanitizeIdentifier(param->name);
        }

        output_ << ") {\n";
        indent();

        for (auto& stmt : node.body) {
            stmt->accept(*this);
        }

        dedent();
        writeLine("}");
    }
}

// Continue with remaining visitor methods in next part due to size...
// For now, let me create stubs for the remaining methods

void Cpp20Backend::visit(Parser::MethodDecl& node) {
    // Method implementation (complex - would need full implementation)
    // For now, basic structure
    std::string methodName = sanitizeIdentifier(node.name);
    std::string returnType = getOwnershipType(node.returnType->ownership, node.returnType->typeName);

    output_ << getIndent() << returnType << " " << methodName << "(";

    for (size_t i = 0; i < node.parameters.size(); ++i) {
        if (i > 0) output_ << ", ";
        auto& param = node.parameters[i];
        output_ << getParameterType(param->type->ownership, param->type->typeName)
               << " " << sanitizeIdentifier(param->name);
    }

    output_ << ") {\n";
    indent();

    for (auto& stmt : node.body) {
        stmt->accept(*this);
    }

    dedent();
    writeLine("}");
}

void Cpp20Backend::visit(Parser::ParameterDecl& node) {}

void Cpp20Backend::visit(Parser::EntrypointDecl& node) {
    writeLine("int main() {");
    indent();

    for (auto& stmt : node.body) {
        stmt->accept(*this);
    }

    dedent();
    writeLine("}");
    writeLine("");
}

// Statement visitors
void Cpp20Backend::visit(Parser::InstantiateStmt& node) {
    std::string varName = sanitizeIdentifier(node.variableName);
    std::string type = getOwnershipType(node.type->ownership, node.type->typeName);

    output_ << getIndent() << type << " " << varName << " = ";

    bool isSmartPtr = requiresSmartPointer(node.type->typeName, node.type->ownership);
    variableIsSmartPointer_[node.variableName] = isSmartPtr;

    node.initializer->accept(*this);
    output_ << ";\n";
}

void Cpp20Backend::visit(Parser::RunStmt& node) {
    output_ << getIndent();
    node.expression->accept(*this);
    output_ << ";\n";
}

void Cpp20Backend::visit(Parser::ForStmt& node) {
    output_ << getIndent() << "for (";

    std::string iteratorType = convertType(node.iteratorType->typeName);
    std::string iteratorName = sanitizeIdentifier(node.iteratorName);

    output_ << iteratorType << " " << iteratorName << " = ";
    node.rangeStart->accept(*this);
    output_ << "; " << iteratorName << " < ";
    node.rangeEnd->accept(*this);
    output_ << "; ++" << iteratorName << ") {\n";

    indent();
    for (auto& stmt : node.body) {
        stmt->accept(*this);
    }
    dedent();

    writeLine("}");
}

void Cpp20Backend::visit(Parser::ExitStmt& node) {
    writeLine("std::exit(0);");
}

void Cpp20Backend::visit(Parser::ReturnStmt& node) {
    output_ << getIndent() << "return ";
    if (node.value) {
        node.value->accept(*this);
    }
    output_ << ";\n";
}

void Cpp20Backend::visit(Parser::IfStmt& node) {
    output_ << getIndent() << "if (";
    node.condition->accept(*this);
    output_ << ") {\n";

    indent();
    for (auto& stmt : node.thenBranch) {
        stmt->accept(*this);
    }
    dedent();

    if (!node.elseBranch.empty()) {
        writeLine("} else {");
        indent();
        for (auto& stmt : node.elseBranch) {
            stmt->accept(*this);
        }
        dedent();
    }

    writeLine("}");
}

void Cpp20Backend::visit(Parser::WhileStmt& node) {
    output_ << getIndent() << "while (";
    node.condition->accept(*this);
    output_ << ") {\n";

    indent();
    for (auto& stmt : node.body) {
        stmt->accept(*this);
    }
    dedent();

    writeLine("}");
}

void Cpp20Backend::visit(Parser::BreakStmt& node) {
    writeLine("break;");
}

void Cpp20Backend::visit(Parser::ContinueStmt& node) {
    writeLine("continue;");
}

void Cpp20Backend::visit(Parser::AssignmentStmt& node) {
    std::string varName = sanitizeIdentifier(node.variableName);

    // Check if this variable is a smart pointer (Owned<T>)
    bool isSmartPtr = variableIsSmartPointer_[node.variableName];

    output_ << getIndent() << varName << " = ";

    if (isSmartPtr) {
        // For smart pointers, wrap in std::move if needed
        if (dynamic_cast<Parser::MemberAccessExpr*>(node.value.get()) ||
            dynamic_cast<Parser::IdentifierExpr*>(node.value.get())) {
            output_ << "std::move(";
            node.value->accept(*this);
            output_ << ")";
        } else {
            node.value->accept(*this);
        }
    } else {
        // Regular assignment
        node.value->accept(*this);
    }

    output_ << ";\n";
}

// Expression visitors
void Cpp20Backend::visit(Parser::IntegerLiteralExpr& node) {
    output_ << std::string("Integer(") + std::to_string(node.value) + ")";
}

void Cpp20Backend::visit(Parser::StringLiteralExpr& node) {
    output_ << std::string("String(\"") + node.value + "\")";
}

void Cpp20Backend::visit(Parser::BoolLiteralExpr& node) {
    output_ << std::string("Bool(") + (node.value ? "true" : "false") + ")";
}

void Cpp20Backend::visit(Parser::ThisExpr& node) {
    output_ << "this";
}

void Cpp20Backend::visit(Parser::IdentifierExpr& node) {
    output_ << sanitizeIdentifier(node.name);
}

void Cpp20Backend::visit(Parser::ReferenceExpr& node) {
    output_ << "&";
    node.expr->accept(*this);
}

void Cpp20Backend::visit(Parser::MemberAccessExpr& node) {
    node.object->accept(*this);

    bool useArrow = false;
    if (auto* id = dynamic_cast<Parser::IdentifierExpr*>(node.object.get())) {
        useArrow = variableIsSmartPointer_[id->name];
    }

    output_ << (useArrow ? "->" : ".") << sanitizeIdentifier(node.member);
}

void Cpp20Backend::visit(Parser::CallExpr& node) {
    node.callee->accept(*this);
    output_ << "(";

    for (size_t i = 0; i < node.arguments.size(); ++i) {
        if (i > 0) output_ << ", ";
        node.arguments[i]->accept(*this);
    }

    output_ << ")";
}

void Cpp20Backend::visit(Parser::BinaryExpr& node) {
    // ✅ USE OPERATOR REGISTRY for code generation!
    if (context_) {
        node.left->accept(*this);
        std::string leftCode = output_.str();
        output_.str("");

        node.right->accept(*this);
        std::string rightCode = output_.str();
        output_.str("");

        std::string result = context_->operators().generateBinaryCpp(node.op, leftCode, rightCode);
        output_ << result;
    } else {
        // Fallback
        output_ << "(";
        node.left->accept(*this);
        output_ << " " << node.op << " ";
        node.right->accept(*this);
        output_ << ")";
    }
}

void Cpp20Backend::visit(Parser::TypeRef& node) {
    output_ << convertType(node.typeName);
}

// Constraint-related visitor methods (compile-time only, no code generation)
void Cpp20Backend::visit(Parser::ConstraintDecl& node) {
    // No code generation - constraints are compile-time only
}

void Cpp20Backend::visit(Parser::RequireStmt& node) {
    // No code generation - requirements are compile-time only
}

void Cpp20Backend::visit(Parser::TypeOfExpr& node) {
    // This should not appear in generated code
    // TypeOf is only used in constraint Truth conditions
}

} // namespace XXML::Backends
