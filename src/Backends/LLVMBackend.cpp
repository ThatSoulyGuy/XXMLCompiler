#include "Backends/LLVMBackend.h"
#include "Core/CompilationContext.h"
#include "Core/TypeRegistry.h"
#include "Core/OperatorRegistry.h"
#include "Core/FormatCompat.h"  // Compatibility layer for std::format
#include <sstream>

namespace XXML::Backends {

LLVMBackend::LLVMBackend(Core::CompilationContext* context)
    : BackendBase() {
    context_ = context;

    // Set capabilities
    addCapability(Core::BackendCapability::Optimizations);
    addCapability(Core::BackendCapability::ValueSemantics);
}

bool LLVMBackend::supportsFeature(std::string_view feature) const {
    return feature == "optimizations" ||
           feature == "jit" ||
           feature == "multi_target";
}

void LLVMBackend::initialize(Core::CompilationContext& context) {
    context_ = &context;
    reset();
}

std::string LLVMBackend::generate(Parser::Program& program) {
    output_.str("");
    output_.clear();
    registerCounter_ = 0;
    labelCounter_ = 0;

    // Generate preamble
    output_ << generatePreamble();

    // Visit program
    program.accept(*this);

    return output_.str();
}

std::string LLVMBackend::generateHeader(Parser::Program& program) {
    // LLVM IR doesn't separate headers and implementation
    return generate(program);
}

std::string LLVMBackend::generateImplementation(Parser::Program& program) {
    // LLVM IR doesn't separate headers and implementation
    return generate(program);
}

std::string LLVMBackend::generatePreamble() {
    std::stringstream preamble;

    preamble << "; Generated by XXML Compiler v2.0 (LLVM IR Backend)\n";
    preamble << "; Target: LLVM IR 17.0\n";
    preamble << ";\n\n";

    // Declare LLVM types for XXML built-in types
    preamble << "; Built-in type definitions\n";
    preamble << "%Integer = type { i64 }\n";
    preamble << "%String = type { ptr }\n";
    preamble << "%Bool = type { i1 }\n";
    preamble << "%Float = type { float }\n";
    preamble << "%Double = type { double }\n";
    preamble << "\n";

    // Declare external functions (runtime library)
    preamble << "; Runtime library functions\n";
    preamble << "declare void @print(ptr)\n";
    preamble << "declare ptr @malloc(i64)\n";
    preamble << "declare void @free(ptr)\n";
    preamble << "\n";

    return preamble.str();
}

std::vector<std::string> LLVMBackend::getRequiredIncludes() const {
    return {};  // LLVM IR doesn't use includes
}

std::vector<std::string> LLVMBackend::getRequiredLibraries() const {
    return {"LLVM"};
}

std::string LLVMBackend::convertType(std::string_view xxmlType) const {
    return getLLVMType(std::string(xxmlType));
}

std::string LLVMBackend::convertOwnership(std::string_view type,
                                         std::string_view ownershipIndicator) const {
    // In LLVM IR, all objects are pointers by default
    // Ownership is handled by the runtime
    if (ownershipIndicator == "&") {
        return std::format("ptr");  // Reference
    } else if (ownershipIndicator == "%") {
        return getLLVMType(std::string(type));  // Value
    } else {
        return std::format("ptr");  // Owned (pointer)
    }
}

std::string LLVMBackend::allocateRegister() {
    return std::format("%r{}", registerCounter_++);
}

std::string LLVMBackend::allocateLabel(std::string_view prefix) {
    return std::format("{}_{}", prefix, labelCounter_++);
}

void LLVMBackend::emitLine(const std::string& line) {
    output_ << getIndent() << line << "\n";
}

std::string LLVMBackend::getLLVMType(const std::string& xxmlType) {
    if (!context_) {
        // Fallback without context
        if (xxmlType == "Integer") return "i64";
        if (xxmlType == "Bool") return "i1";
        if (xxmlType == "Float") return "float";
        if (xxmlType == "Double") return "double";
        if (xxmlType == "String") return "ptr";
        return "ptr";
    }

    // ✅ USE TYPE REGISTRY for LLVM type mapping
    const auto* typeInfo = context_->types().getTypeInfo(xxmlType);
    if (typeInfo && !typeInfo->llvmType.empty()) {
        return typeInfo->llvmType;
    }

    // Default to pointer for user-defined types
    return "ptr";
}

std::string LLVMBackend::generateBinaryOp(const std::string& op,
                                         const std::string& lhs,
                                         const std::string& rhs,
                                         const std::string& type) {
    // ✅ USE OPERATOR REGISTRY for LLVM generation
    if (context_) {
        return context_->operators().generateBinaryLLVM(op, lhs, rhs);
    }

    // Fallback: basic LLVM operations
    if (op == "+") return std::format("add {} {}, {}", type, lhs, rhs);
    if (op == "-") return std::format("sub {} {}, {}", type, lhs, rhs);
    if (op == "*") return std::format("mul {} {}, {}", type, lhs, rhs);
    if (op == "/") return std::format("sdiv {} {}, {}", type, lhs, rhs);
    if (op == "==") return std::format("icmp eq {} {}, {}", type, lhs, rhs);
    if (op == "!=") return std::format("icmp ne {} {}, {}", type, lhs, rhs);
    if (op == "<") return std::format("icmp slt {} {}, {}", type, lhs, rhs);
    if (op == ">") return std::format("icmp sgt {} {}, {}", type, lhs, rhs);

    return std::format("; Unknown op: {} {} {}", lhs, op, rhs);
}

// Visitor implementations (simplified skeletons)
void LLVMBackend::visit(Parser::Program& node) {
    for (auto& decl : node.declarations) {
        decl->accept(*this);
    }
}

void LLVMBackend::visit(Parser::ImportDecl& node) {
    emitLine(std::format("; import {}", node.modulePath));
}

void LLVMBackend::visit(Parser::NamespaceDecl& node) {
    emitLine(std::format("; namespace {}", node.name));
    for (auto& decl : node.declarations) {
        decl->accept(*this);
    }
}

void LLVMBackend::visit(Parser::ClassDecl& node) {
    emitLine(std::format("; class {}", node.name));
    // In LLVM IR, classes become struct types
    emitLine(std::format("%class.{} = type {{ }}", node.name));
}

void LLVMBackend::visit(Parser::AccessSection& node) {
    for (auto& decl : node.declarations) {
        decl->accept(*this);
    }
}

void LLVMBackend::visit(Parser::PropertyDecl& node) {
    // Properties are part of class struct
}

void LLVMBackend::visit(Parser::ConstructorDecl& node) {
    // Constructor becomes a regular function
}

void LLVMBackend::visit(Parser::MethodDecl& node) {
    emitLine(std::format("define {} @{}() {{", getLLVMType(node.returnType->typeName), node.name));
    indent();

    for (auto& stmt : node.body) {
        stmt->accept(*this);
    }

    dedent();
    emitLine("}");
    emitLine("");
}

void LLVMBackend::visit(Parser::ParameterDecl& node) {}

void LLVMBackend::visit(Parser::EntrypointDecl& node) {
    emitLine("define i32 @main() {");
    indent();

    for (auto& stmt : node.body) {
        stmt->accept(*this);
    }

    emitLine("ret i32 0");
    dedent();
    emitLine("}");
}

void LLVMBackend::visit(Parser::InstantiateStmt& node) {
    std::string reg = allocateRegister();
    emitLine(std::format("{} = alloca {}", reg, getLLVMType(node.type->typeName)));
    valueMap_[node.variableName] = reg;
}

void LLVMBackend::visit(Parser::RunStmt& node) {
    node.expression->accept(*this);
}

void LLVMBackend::visit(Parser::ForStmt& node) {
    std::string condLabel = allocateLabel("for_cond");
    std::string bodyLabel = allocateLabel("for_body");
    std::string endLabel = allocateLabel("for_end");

    emitLine(std::format("br label %{}", condLabel));
    emitLine(std::format("{}:", condLabel));
    // ... loop implementation
}

void LLVMBackend::visit(Parser::ExitStmt& node) {
    emitLine("call void @exit(i32 0)");
}

void LLVMBackend::visit(Parser::ReturnStmt& node) {
    if (node.value) {
        node.value->accept(*this);
        emitLine("ret i64 0  ; placeholder");
    } else {
        emitLine("ret void");
    }
}

void LLVMBackend::visit(Parser::IfStmt& node) {
    std::string thenLabel = allocateLabel("if_then");
    std::string elseLabel = allocateLabel("if_else");
    std::string endLabel = allocateLabel("if_end");

    node.condition->accept(*this);
    emitLine(std::format("br i1 %cond, label %{}, label %{}",
                        thenLabel, elseLabel));

    emitLine(std::format("{}:", thenLabel));
    indent();
    for (auto& stmt : node.thenBody) {
        stmt->accept(*this);
    }
    dedent();
    emitLine(std::format("br label %{}", endLabel));

    emitLine(std::format("{}:", elseLabel));
    indent();
    for (auto& stmt : node.elseBody) {
        stmt->accept(*this);
    }
    dedent();
    emitLine(std::format("br label %{}", endLabel));

    emitLine(std::format("{}:", endLabel));
}

void LLVMBackend::visit(Parser::WhileStmt& node) {
    std::string condLabel = allocateLabel("while_cond");
    std::string bodyLabel = allocateLabel("while_body");
    std::string endLabel = allocateLabel("while_end");

    emitLine(std::format("br label %{}", condLabel));
    emitLine(std::format("{}:", condLabel));
    // ... implementation
}

void LLVMBackend::visit(Parser::BreakStmt& node) {
    emitLine("br label %loop_end  ; break");
}

void LLVMBackend::visit(Parser::ContinueStmt& node) {
    emitLine("br label %loop_cond  ; continue");
}

void LLVMBackend::visit(Parser::IntegerLiteralExpr& node) {
    emitLine(std::format("i64 {}", node.value));
}

void LLVMBackend::visit(Parser::StringLiteralExpr& node) {
    emitLine(std::format("ptr @.str.{}  ; \"{}\"", labelCounter_++, node.value));
}

void LLVMBackend::visit(Parser::BoolLiteralExpr& node) {
    emitLine(std::format("i1 {}", node.value ? "true" : "false"));
}

void LLVMBackend::visit(Parser::ThisExpr& node) {
    emitLine("ptr %this");
}

void LLVMBackend::visit(Parser::IdentifierExpr& node) {
    auto it = valueMap_.find(node.name);
    if (it != valueMap_.end()) {
        emitLine(it->second);
    } else {
        emitLine(std::format("@{}", node.name));
    }
}

void LLVMBackend::visit(Parser::ReferenceExpr& node) {
    node.expression->accept(*this);
}

void LLVMBackend::visit(Parser::MemberAccessExpr& node) {
    emitLine("; member access (placeholder)");
}

void LLVMBackend::visit(Parser::CallExpr& node) {
    emitLine("; function call (placeholder)");
}

void LLVMBackend::visit(Parser::BinaryExpr& node) {
    node.left->accept(*this);
    std::string leftReg = allocateRegister();

    node.right->accept(*this);
    std::string rightReg = allocateRegister();

    std::string resultReg = allocateRegister();
    emitLine(std::format("{} = {}", resultReg,
                        generateBinaryOp(node.op, leftReg, rightReg, "i64")));
}

void LLVMBackend::visit(Parser::TypeRef& node) {
    emitLine(getLLVMType(node.typeName));
}

} // namespace XXML::Backends
