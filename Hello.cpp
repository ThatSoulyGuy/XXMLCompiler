// Generated by XXML Compiler

#include <iostream>
#include <string>
#include <memory>
#include <cstdint>
#include <cstring>

// Syscall intrinsic functions
class Syscall {
public:
    static void* string_create(const void* cstr) {
        return (void*)new std::string((const char*)cstr);
    }
    static const char* string_cstr(void* ptr) {
        return ((std::string*)ptr)->c_str();
    }
    static int64_t string_length(void* ptr) {
        return ((std::string*)ptr)->length();
    }
    static void* string_concat(void* ptr1, void* ptr2) {
        std::string* s1 = (std::string*)ptr1;
        std::string* s2 = (std::string*)ptr2;
        return (void*)new std::string(*s1 + *s2);
    }
    static void* string_copy(void* ptr) {
        return (void*)new std::string(*(std::string*)ptr);
    }
    static int64_t string_equals(void* ptr1, void* ptr2) {
        return (*(std::string*)ptr1 == *(std::string*)ptr2) ? 1 : 0;
    }
    static void string_destroy(void* ptr) {
        delete (std::string*)ptr;
    }
    static void memcpy(void* dest, const void* src, size_t n) {
        std::memcpy(dest, src, n);
    }
};

// StringArray stub
class StringArray {
public:
    StringArray() {}
};

// Forward declarations
namespace Language::Core {
    class Bool;
    class Integer;
    class Float;
    class Double;
    class String;
}
namespace System {
    class Console;
}

// ============================================
// Core Library - Class Declarations
// ============================================

namespace Language::Core {

    class Integer {
        private:
            int64_t value;
        public:
            Integer() = default;
            Integer(int64_t val) : value(val) {}
            int64_t toInt64();
            Integer add(Integer other);
            Integer subtract(Integer other);
            Integer multiply(Integer other);
            Integer divide(Integer other);
            Integer modulo(Integer other);
            Bool equals(Integer other);
            Bool lessThan(Integer other);
            Bool greaterThan(Integer other);
            Bool lessOrEqual(Integer other);
            Bool greaterOrEqual(Integer other);
            Integer negate();
            Integer abs();
    };
    
} // namespace Language::Core

namespace Language::Core {

    class Bool {
        private:
            bool value;
        public:
            Bool() = default;
            Bool(bool val) : value(val) {}
            bool toBool();
            Bool and_(Bool other);
            Bool or_(Bool other);
            Bool not_();
            Bool xor_(Bool other);
            Bool equals(Bool other);
            Integer toInteger();
    };
    
} // namespace Language::Core

namespace Language::Core {

    class Float {
        private:
            float value;
        public:
            Float() = default;
            Float(float val) : value(val) {}
            float toFloat();
            std::unique_ptr<Float> add(std::unique_ptr<Float> other);
            std::unique_ptr<Float> subtract(std::unique_ptr<Float> other);
            std::unique_ptr<Float> multiply(std::unique_ptr<Float> other);
            std::unique_ptr<Float> divide(std::unique_ptr<Float> other);
            Bool equals(std::unique_ptr<Float> other);
            Bool lessThan(std::unique_ptr<Float> other);
            Bool greaterThan(std::unique_ptr<Float> other);
            std::unique_ptr<Float> negate();
            std::unique_ptr<Float> abs();
            Integer toInteger();
            std::unique_ptr<Double> toDouble();
    };
    
} // namespace Language::Core

namespace Language::Core {

    class Double {
        private:
            double value;
        public:
            Double() = default;
            Double(double val) : value(val) {}
            double toDouble();
            std::unique_ptr<Double> add(std::unique_ptr<Double> other);
            std::unique_ptr<Double> subtract(std::unique_ptr<Double> other);
            std::unique_ptr<Double> multiply(std::unique_ptr<Double> other);
            std::unique_ptr<Double> divide(std::unique_ptr<Double> other);
            Bool equals(std::unique_ptr<Double> other);
            Bool lessThan(std::unique_ptr<Double> other);
            Bool greaterThan(std::unique_ptr<Double> other);
            Bool lessOrEqual(std::unique_ptr<Double> other);
            Bool greaterOrEqual(std::unique_ptr<Double> other);
            std::unique_ptr<Double> negate();
            std::unique_ptr<Double> abs();
            Integer toInteger();
            std::unique_ptr<Float> toFloat();
    };
    
} // namespace Language::Core

namespace Language::Core {

    class String {
        private:
            void* data;
        public:
            String() = default;
            String(const void* cstr) {
                void* ptr = Syscall::string_create(cstr);
                Syscall::memcpy(data, ptr, 8);
            }
            const void* toCString();
            Integer length();
            Bool isEmpty();
            String append(String other);
            String copy();
            Bool equals(String other);
            void dispose();
    };
    
} // namespace Language::Core

// ============================================
// Core Library - Method Implementations
// ============================================

namespace Language::Core {

        int64_t Language::Core::Integer::toInt64() {
        return value;
    }
    Integer Language::Core::Integer::add(Integer other) {
        int64_t v1 = value;
        int64_t v2 = other.value;
        int64_t result = v1 + v2;
        return Language::Core::Integer(result);
    }
    Integer Language::Core::Integer::subtract(Integer other) {
        int64_t v1 = value;
        int64_t v2 = other.value;
        int64_t result = v1 - v2;
        return Language::Core::Integer(result);
    }
    Integer Language::Core::Integer::multiply(Integer other) {
        int64_t v1 = value;
        int64_t v2 = other.value;
        int64_t result = v1 * v2;
        return Language::Core::Integer(result);
    }
    Integer Language::Core::Integer::divide(Integer other) {
        int64_t v1 = value;
        int64_t v2 = other.value;
        int64_t result = v1 / v2;
        return Language::Core::Integer(result);
    }
    Integer Language::Core::Integer::modulo(Integer other) {
        int64_t v1 = value;
        int64_t v2 = other.value;
        int64_t result = v1 % v2;
        return Language::Core::Integer(result);
    }
    Bool Language::Core::Integer::equals(Integer other) {
        int64_t v1 = value;
        int64_t v2 = other.value;
        if (v1 == v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Bool Language::Core::Integer::lessThan(Integer other) {
        int64_t v1 = value;
        int64_t v2 = other.value;
        if (v1 < v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Bool Language::Core::Integer::greaterThan(Integer other) {
        int64_t v1 = value;
        int64_t v2 = other.value;
        if (v1 > v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Bool Language::Core::Integer::lessOrEqual(Integer other) {
        int64_t v1 = value;
        int64_t v2 = other.value;
        if (v1 <= v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Bool Language::Core::Integer::greaterOrEqual(Integer other) {
        int64_t v1 = value;
        int64_t v2 = other.value;
        if (v1 >= v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Integer Language::Core::Integer::negate() {
        int64_t v = value;
        int64_t result = 0 - v;
        return Language::Core::Integer(result);
    }
    Integer Language::Core::Integer::abs() {
        int64_t v = value;
        if (v < 0) {
            int64_t result = 0 - v;
            return Language::Core::Integer(result);
        }
        return Language::Core::Integer(v);
    }
} // namespace Language::Core

namespace Language::Core {

        bool Language::Core::Bool::toBool() {
        return value;
    }
    Bool Language::Core::Bool::and_(Bool other) {
        bool v1 = value;
        bool v2 = other.value;
        bool result = v1 && v2;
        return Language::Core::Bool(result);
    }
    Bool Language::Core::Bool::or_(Bool other) {
        bool v1 = value;
        bool v2 = other.value;
        bool result = v1 || v2;
        return Language::Core::Bool(result);
    }
    Bool Language::Core::Bool::not_() {
        bool v = value;
        bool result = !v;
        return Language::Core::Bool(result);
    }
    Bool Language::Core::Bool::xor_(Bool other) {
        bool v1 = value;
        bool v2 = other.value;
        if (v1 == v2) {
            return Language::Core::Bool(false);
        }
        return Language::Core::Bool(true);
    }
    Bool Language::Core::Bool::equals(Bool other) {
        bool v1 = value;
        bool v2 = other.value;
        if (v1 == v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Integer Language::Core::Bool::toInteger() {
        bool v = value;
        if (v == true) {
            return Language::Core::Integer(1);
        }
        return Language::Core::Integer(0);
    }
} // namespace Language::Core

namespace Language::Core {

        float Language::Core::Float::toFloat() {
        return value;
    }
    std::unique_ptr<Float> Language::Core::Float::add(std::unique_ptr<Float> other) {
        float v1 = value;
        float v2 = other->value;
        float result = v1 + v2;
        return std::make_unique<Float>(result);
    }
    std::unique_ptr<Float> Language::Core::Float::subtract(std::unique_ptr<Float> other) {
        float v1 = value;
        float v2 = other->value;
        float result = v1 - v2;
        return std::make_unique<Float>(result);
    }
    std::unique_ptr<Float> Language::Core::Float::multiply(std::unique_ptr<Float> other) {
        float v1 = value;
        float v2 = other->value;
        float result = v1 * v2;
        return std::make_unique<Float>(result);
    }
    std::unique_ptr<Float> Language::Core::Float::divide(std::unique_ptr<Float> other) {
        float v1 = value;
        float v2 = other->value;
        float result = v1 / v2;
        return std::make_unique<Float>(result);
    }
    Bool Language::Core::Float::equals(std::unique_ptr<Float> other) {
        float v1 = value;
        float v2 = other->value;
        if (v1 == v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Bool Language::Core::Float::lessThan(std::unique_ptr<Float> other) {
        float v1 = value;
        float v2 = other->value;
        if (v1 < v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Bool Language::Core::Float::greaterThan(std::unique_ptr<Float> other) {
        float v1 = value;
        float v2 = other->value;
        if (v1 > v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    std::unique_ptr<Float> Language::Core::Float::negate() {
        float v = value;
        float zero = 0;
        float result = zero - v;
        return std::make_unique<Float>(result);
    }
    std::unique_ptr<Float> Language::Core::Float::abs() {
        float v = value;
        float zero = 0;
        if (v < zero) {
            float result = zero - v;
            return std::make_unique<Float>(result);
        }
        return std::make_unique<Float>(v);
    }
    Integer Language::Core::Float::toInteger() {
        float v = value;
        int64_t result = v;
        return Language::Core::Integer(result);
    }
    std::unique_ptr<Double> Language::Core::Float::toDouble() {
        float v = value;
        double result = v;
        return std::make_unique<Double>(result);
    }
} // namespace Language::Core

namespace Language::Core {

        double Language::Core::Double::toDouble() {
        return value;
    }
    std::unique_ptr<Double> Language::Core::Double::add(std::unique_ptr<Double> other) {
        double v1 = value;
        double v2 = other->value;
        double result = v1 + v2;
        return std::make_unique<Double>(result);
    }
    std::unique_ptr<Double> Language::Core::Double::subtract(std::unique_ptr<Double> other) {
        double v1 = value;
        double v2 = other->value;
        double result = v1 - v2;
        return std::make_unique<Double>(result);
    }
    std::unique_ptr<Double> Language::Core::Double::multiply(std::unique_ptr<Double> other) {
        double v1 = value;
        double v2 = other->value;
        double result = v1 * v2;
        return std::make_unique<Double>(result);
    }
    std::unique_ptr<Double> Language::Core::Double::divide(std::unique_ptr<Double> other) {
        double v1 = value;
        double v2 = other->value;
        double result = v1 / v2;
        return std::make_unique<Double>(result);
    }
    Bool Language::Core::Double::equals(std::unique_ptr<Double> other) {
        double v1 = value;
        double v2 = other->value;
        if (v1 == v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Bool Language::Core::Double::lessThan(std::unique_ptr<Double> other) {
        double v1 = value;
        double v2 = other->value;
        if (v1 < v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Bool Language::Core::Double::greaterThan(std::unique_ptr<Double> other) {
        double v1 = value;
        double v2 = other->value;
        if (v1 > v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Bool Language::Core::Double::lessOrEqual(std::unique_ptr<Double> other) {
        double v1 = value;
        double v2 = other->value;
        if (v1 <= v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Bool Language::Core::Double::greaterOrEqual(std::unique_ptr<Double> other) {
        double v1 = value;
        double v2 = other->value;
        if (v1 >= v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    std::unique_ptr<Double> Language::Core::Double::negate() {
        double v = value;
        double zero = 0;
        double result = zero - v;
        return std::make_unique<Double>(result);
    }
    std::unique_ptr<Double> Language::Core::Double::abs() {
        double v = value;
        double zero = 0;
        if (v < zero) {
            double result = zero - v;
            return std::make_unique<Double>(result);
        }
        return std::make_unique<Double>(v);
    }
    Integer Language::Core::Double::toInteger() {
        double v = value;
        int64_t result = v;
        return Language::Core::Integer(result);
    }
    std::unique_ptr<Float> Language::Core::Double::toFloat() {
        double v = value;
        float result = v;
        return std::make_unique<Float>(result);
    }
} // namespace Language::Core

namespace Language::Core {

        const void* Language::Core::String::toCString() {
        void* ptr = data;
        return Syscall::string_cstr(ptr);
    }
    Integer Language::Core::String::length() {
        void* ptr = data;
        int64_t len = Syscall::string_length(ptr);
        return Language::Core::Integer(len);
    }
    Bool Language::Core::String::isEmpty() {
        void* ptr = data;
        int64_t len = Syscall::string_length(ptr);
        if (len == 0) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    String Language::Core::String::append(String other) {
        void* ptr1 = data;
        void* ptr2 = other.data;
        void* newPtr = Syscall::string_concat(ptr1, ptr2);
        Syscall::memcpy(data, newPtr, 8);
        return this;
    }
    String Language::Core::String::copy() {
        String result = Language::Core::String();
        void* ptr = data;
        void* newPtr = Syscall::string_copy(ptr);
        Syscall::memcpy(result.data, newPtr, 8);
        return result;
    }
    Bool Language::Core::String::equals(String other) {
        void* ptr1 = data;
        void* ptr2 = other.data;
        int64_t result = Syscall::string_equals(ptr1, ptr2);
        if (result == 1) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    void Language::Core::String::dispose() {
        void* ptr = data;
        if (ptr != 0) {
            Syscall::string_destroy(ptr);
            void* zero = 0;
            Syscall::memcpy(data, zero, 8);
        }
    }
} // namespace Language::Core

// ============================================
// Module: Language/System/Console.XXML
// ============================================
namespace System {

    class Console {
        public:
            static void print(Language::Core::String message) {
                std::cout << (const char*)message.toCString();
            }
            static void printLine(Language::Core::String message) {
                std::cout << (const char*)message.toCString() << std::endl;
            }
            static void printError(Language::Core::String message) {
                std::cerr << (const char*)message.toCString() << std::endl;
            }
            static void clear() {
                #ifdef _WIN32
                    system("cls");
                #else
                    system("clear");
                #endif
            }
            static Language::Core::String readLine() {
                return Language::Core::String();
            }
            static Language::Core::String readChar() {
                return Language::Core::String();
            }
            static Language::Core::Integer readInt() {
                return Language::Core::Integer(0);
            }
            static void printFormatted(Language::Core::String format, Language::Core::String value) {
            }
            static Language::Core::Integer getTime() {
                return Language::Core::Integer(0);
            }
            static Language::Core::Integer getTimeMillis() {
                return Language::Core::Integer(0);
            }
            static void sleep(Language::Core::Integer milliseconds) {
            }
            static Language::Core::String getEnv(Language::Core::String varName) {
                return Language::Core::String();
            }
            static Language::Core::Bool setEnv(Language::Core::String varName, Language::Core::String value) {
                return Language::Core::Bool(false);
            }
            static void exit(Language::Core::Integer exitCode) {
            }
            static std::unique_ptr<StringArray> getArgs() {
                return std::make_unique<StringArray>();
            }
    };
    
} // namespace System



// ============================================
// Module: __main__
// ============================================
int main() {
    System::Console::printLine(Language::Core::String("Hello world!"));
}



