// Threading Test - Tests the new class-based threading API
#import Language::Core;
#import Language::Concurrent;

[ Entrypoint
    {
        Run Console::printLine(String::Constructor("=== Threading Class Test ==="));

        // Test 1: Basic Thread Spawn
        Run Console::printLine(String::Constructor("1. Testing Thread::spawn..."));
        Instantiate F(None^)()^ As <worker> = [ Lambda [] Returns None^ Parameters () {
            Run Console::printLine(String::Constructor("   Hello from worker thread!"));
            Return None::Constructor();
        }];

        Instantiate Concurrent::Thread^ As <t1> = Concurrent::Thread::spawn(worker);
        Run t1.join();
        Run Console::printLine(String::Constructor("   Thread joined."));

        // Test 2: Mutex
        Run Console::printLine(String::Constructor("2. Testing Mutex..."));
        Instantiate Concurrent::Mutex^ As <mutex> = Concurrent::Mutex::Constructor();

        If (mutex.isValid()) -> {
            Run Console::printLine(String::Constructor("   Mutex created successfully."));
        }

        Run mutex.lock();
        Run Console::printLine(String::Constructor("   Mutex locked."));
        Run mutex.unlock();
        Run Console::printLine(String::Constructor("   Mutex unlocked."));

        // Test 3: Atomic
        Run Console::printLine(String::Constructor("3. Testing Atomic..."));
        Instantiate Concurrent::Atomic^ As <counter> = Concurrent::Atomic::Constructor();

        Run counter.increment();
        Run counter.increment();
        Run counter.increment();

        Instantiate Integer^ As <val> = counter.get();
        Run Console::printLine(String::Constructor("   Counter value after 3 increments: "));
        Run Console::printLine(val.toString());

        // Test 4: Atomic with initial value
        Run Console::printLine(String::Constructor("4. Testing Atomic with initial value..."));
        Instantiate Concurrent::Atomic^ As <counter2> = Concurrent::Atomic::Constructor(Integer::Constructor(100));

        Run counter2.add(Integer::Constructor(50));
        Instantiate Integer^ As <val2> = counter2.get();
        Run Console::printLine(String::Constructor("   Counter (100 + 50): "));
        Run Console::printLine(val2.toString());

        // Test 5: Thread utilities
        Run Console::printLine(String::Constructor("5. Testing Thread utilities..."));
        Instantiate Integer^ As <tid> = Concurrent::Thread::currentId();
        Run Console::printLine(String::Constructor("   Current thread ID: "));
        Run Console::printLine(tid.toString());

        Run Console::printLine(String::Constructor("   Sleeping for 100ms..."));
        Run Concurrent::Thread::sleep(Integer::Constructor(100));
        Run Console::printLine(String::Constructor("   Done sleeping."));

        // Test 6: LockGuard
        Run Console::printLine(String::Constructor("6. Testing LockGuard..."));
        Instantiate Concurrent::Mutex^ As <mutex2> = Concurrent::Mutex::Constructor();
        {
            Instantiate Concurrent::LockGuard^ As <guard> = Concurrent::LockGuard::Constructor(mutex2);
            If (guard.ownsTheLock()) -> {
                Run Console::printLine(String::Constructor("   LockGuard acquired lock."));
            }
        }
        Run Console::printLine(String::Constructor("   LockGuard released (out of scope)."));

        // Test 7: Parallel counter with atomic
        Run Console::printLine(String::Constructor("7. Testing parallel atomic counter..."));
        Instantiate Concurrent::Atomic^ As <sharedCounter> = Concurrent::Atomic::Constructor();

        Instantiate F(None^)()^ As <adder1> = [ Lambda [&sharedCounter] Returns None^ Parameters () {
            Run sharedCounter.increment();
            Run sharedCounter.increment();
            Run sharedCounter.increment();
            Return None::Constructor();
        }];

        Instantiate F(None^)()^ As <adder2> = [ Lambda [&sharedCounter] Returns None^ Parameters () {
            Run sharedCounter.increment();
            Run sharedCounter.increment();
            Run sharedCounter.increment();
            Return None::Constructor();
        }];

        Instantiate Concurrent::Thread^ As <thread1> = Concurrent::Thread::spawn(adder1);
        Instantiate Concurrent::Thread^ As <thread2> = Concurrent::Thread::spawn(adder2);

        Run thread1.join();
        Run thread2.join();

        Instantiate Integer^ As <finalCount> = sharedCounter.get();
        Run Console::printLine(String::Constructor("   Final counter (should be 6): "));
        Run Console::printLine(finalCount.toString());

        // Test 8: Compare and Swap
        Run Console::printLine(String::Constructor("8. Testing Compare and Swap..."));
        Instantiate Concurrent::Atomic^ As <casCounter> = Concurrent::Atomic::Constructor(Integer::Constructor(100));

        Instantiate Bool^ As <success> = casCounter.compareAndSwap(Integer::Constructor(100), Integer::Constructor(200));
        If (success) -> {
            Run Console::printLine(String::Constructor("   CAS(100->200) succeeded"));
        } Else -> {
            Run Console::printLine(String::Constructor("   CAS(100->200) failed"));
        }

        // This should fail because value is now 200, not 100
        Instantiate Bool^ As <fail> = casCounter.compareAndSwap(Integer::Constructor(100), Integer::Constructor(300));
        If (fail) -> {
            Run Console::printLine(String::Constructor("   CAS(100->300) succeeded (unexpected)"));
        } Else -> {
            Run Console::printLine(String::Constructor("   CAS(100->300) failed as expected"));
        }

        Instantiate Integer^ As <casVal> = casCounter.get();
        Run Console::printLine(String::Constructor("   Final CAS value: "));
        Run Console::printLine(casVal.toString());

        // Test 9: TryLock
        Run Console::printLine(String::Constructor("9. Testing tryLock..."));
        Instantiate Concurrent::Mutex^ As <mutex3> = Concurrent::Mutex::Constructor();

        Instantiate Bool^ As <got1> = mutex3.tryLock();
        If (got1) -> {
            Run Console::printLine(String::Constructor("   First tryLock succeeded"));

            // Try to lock again (should succeed on Windows with CRITICAL_SECTION)
            // On some systems this may deadlock - we unlock before trying again
            Run mutex3.unlock();

            Instantiate Bool^ As <got2> = mutex3.tryLock();
            If (got2) -> {
                Run Console::printLine(String::Constructor("   Second tryLock succeeded"));
                Run mutex3.unlock();
            } Else -> {
                Run Console::printLine(String::Constructor("   Second tryLock failed"));
            }
        } Else -> {
            Run Console::printLine(String::Constructor("   First tryLock failed"));
        }

        Run Console::printLine(String::Constructor("=== Threading Test Complete ==="));
        Exit(0);
    }
]
