// Generated by XXML Compiler

#include <iostream>
#include <string>
#include <memory>
#include <cstdint>
#include <cstring>
#include <limits>
#include <cassert>
#include <stdexcept>
#include <utility>
#include <type_traits>

// ============================================
// Owned<T> - Runtime wrapper for owned values (T^)
// ============================================
namespace Language {
namespace Runtime {

template<typename T>
class Owned {
private:
    T value_;
    bool movedFrom_;

public:
    Owned() : value_(), movedFrom_(false) {}  // Default constructor
    Owned(const T& val) : value_(val), movedFrom_(false) {}  // Copy for primitives
    Owned(T&& val) : value_(std::move(val)), movedFrom_(false) {}  // Move

    // Copy constructor - enabled for primitive types only (int64_t, double, float, bool, void*)
    Owned(const Owned& other) : value_(other.value_), movedFrom_(false) {
        static_assert(
            std::is_same_v<T, int64_t> || std::is_same_v<T, double> ||
            std::is_same_v<T, float> || std::is_same_v<T, bool> ||
            std::is_same_v<T, void*> || std::is_same_v<T, const void*> ||
            std::is_same_v<T, int32_t>,
            "Owned<T> can only be copied for primitive types. "
            "For complex types, use move semantics or reference parameters.");
    }

    Owned& operator=(const Owned& other) {
        static_assert(
            std::is_same_v<T, int64_t> || std::is_same_v<T, double> ||
            std::is_same_v<T, float> || std::is_same_v<T, bool> ||
            std::is_same_v<T, void*> || std::is_same_v<T, const void*> ||
            std::is_same_v<T, int32_t>,
            "Owned<T> can only be copied for primitive types. "
            "For complex types, use move semantics or reference parameters.");
        if (this != &other) {
            value_ = other.value_;
            movedFrom_ = false;
        }
        return *this;
    }

    Owned(Owned&& other) noexcept
        : value_(std::move(other.value_)), movedFrom_(false) {
        other.movedFrom_ = true;
    }

    Owned& operator=(Owned&& other) noexcept {
        if (this != &other) {
            value_ = std::move(other.value_);
            movedFrom_ = false;
            other.movedFrom_ = true;
        }
        return *this;
    }

    T& get() {
        if (movedFrom_) {
            assert(false && "Use-after-move detected");
            throw std::runtime_error("Use-after-move detected");
        }
        return value_;
    }

    const T& get() const {
        if (movedFrom_) {
            assert(false && "Use-after-move detected");
            throw std::runtime_error("Use-after-move detected");
        }
        return value_;
    }

    T extract() {
        if (movedFrom_) {
            assert(false && "Use-after-move detected");
            throw std::runtime_error("Use-after-move detected");
        }
        movedFrom_ = true;
        return std::move(value_);
    }

    operator T&() { return get(); }
    operator const T&() const { return get(); }
    T* operator->() { return &get(); }
    const T* operator->() const { return &get(); }
    bool isMovedFrom() const { return movedFrom_; }
};

} // namespace Runtime
} // namespace Language

// Syscall intrinsic functions
class Syscall {
public:
    static void* string_create(const void* cstr) {
        return (void*)new std::string((const char*)cstr);
    }
    static const char* string_cstr(void* ptr) {
        return ((std::string*)ptr)->c_str();
    }
    static int64_t string_length(void* ptr) {
        return ((std::string*)ptr)->length();
    }
    static void* string_concat(void* ptr1, void* ptr2) {
        std::string* s1 = (std::string*)ptr1;
        std::string* s2 = (std::string*)ptr2;
        return (void*)new std::string(*s1 + *s2);
    }
    static void* string_copy(void* ptr) {
        return (void*)new std::string(*(std::string*)ptr);
    }
    static int64_t string_equals(void* ptr1, void* ptr2) {
        return (*(std::string*)ptr1 == *(std::string*)ptr2) ? 1 : 0;
    }
    static void string_destroy(void* ptr) {
        delete (std::string*)ptr;
    }
    static void memcpy(void* dest, const void* src, size_t n) {
        std::memcpy(dest, src, n);
    }
    static const char* int_to_string(int64_t value) {
        static thread_local std::string buffer;
        buffer = std::to_string(value);
        return buffer.c_str();
    }
};

// StringArray stub
class StringArray {
public:
    StringArray() {}
    static StringArray Constructor() { return StringArray(); }
};

// System::Console intrinsic class (will be implemented after core types)
namespace System {
class Console;
} // namespace System

// Forward declarations
namespace Language::Core {
    class Bool;
    class Integer;
    class Float;
    class Double;
    class String;
}
namespace System {
    class Console;
}

// ============================================
// Core Library - Class Declarations
// ============================================

namespace Language::Core {

    class Integer {
        private:
            Language::Runtime::Owned<int64_t> value;
        public:
            Integer() = default;
            Integer(int64_t val) : value(val) {}
            static Integer Constructor(int64_t val) { return Integer(val); }
            int64_t toInt64();
            Language::Runtime::Owned<Language::Core::Integer> add(Language::Core::Integer& other);
            Language::Runtime::Owned<Language::Core::Integer> subtract(Language::Core::Integer& other);
            Language::Runtime::Owned<Language::Core::Integer> multiply(Language::Core::Integer& other);
            Language::Runtime::Owned<Language::Core::Integer> divide(Language::Core::Integer& other);
            Language::Runtime::Owned<Language::Core::Integer> modulo(Language::Core::Integer& other);
            Language::Runtime::Owned<Language::Core::Bool> equals(Language::Core::Integer& other);
            Language::Runtime::Owned<Language::Core::Bool> lessThan(Language::Core::Integer& other);
            Language::Runtime::Owned<Language::Core::Bool> greaterThan(Language::Core::Integer& other);
            Language::Runtime::Owned<Language::Core::Bool> lessOrEqual(Language::Core::Integer& other);
            Language::Runtime::Owned<Language::Core::Bool> greaterOrEqual(Language::Core::Integer& other);
            Language::Runtime::Owned<Language::Core::Integer> negate();
            Language::Runtime::Owned<Language::Core::Integer> abs();
            Language::Runtime::Owned<Language::Core::String> toString();
    };
    
} // namespace Language::Core

namespace Language::Core {

    class Bool {
        private:
            Language::Runtime::Owned<bool> value;
        public:
            Bool() = default;
            Bool(bool val) : value(val) {}
            static Bool Constructor(bool val) { return Bool(val); }
            bool toBool();
            Language::Runtime::Owned<Language::Core::Bool> and_(Language::Core::Bool& other);
            Language::Runtime::Owned<Language::Core::Bool> or_(Language::Core::Bool& other);
            Language::Runtime::Owned<Language::Core::Bool> not_();
            Language::Runtime::Owned<Language::Core::Bool> xor_(Language::Core::Bool& other);
            Language::Runtime::Owned<Language::Core::Bool> equals(Language::Core::Bool& other);
            Language::Runtime::Owned<Language::Core::Integer> toInteger();
    };
    
} // namespace Language::Core

namespace Language::Core {

    class Float {
        private:
            Language::Runtime::Owned<float> value;
        public:
            Float() = default;
            Float(float val) : value(val) {}
            static Float Constructor(float val) { return Float(val); }
            float toFloat();
            Language::Runtime::Owned<Language::Core::Float> add(Language::Core::Float& other);
            Language::Runtime::Owned<Language::Core::Float> subtract(Language::Core::Float& other);
            Language::Runtime::Owned<Language::Core::Float> multiply(Language::Core::Float& other);
            Language::Runtime::Owned<Language::Core::Float> divide(Language::Core::Float& other);
            Language::Runtime::Owned<Language::Core::Bool> equals(Language::Core::Float& other);
            Language::Runtime::Owned<Language::Core::Bool> lessThan(Language::Core::Float& other);
            Language::Runtime::Owned<Language::Core::Bool> greaterThan(Language::Core::Float& other);
            Language::Runtime::Owned<Language::Core::Float> negate();
            Language::Runtime::Owned<Language::Core::Float> abs();
            Language::Runtime::Owned<Language::Core::Integer> toInteger();
            Language::Core::Double toDouble();
    };
    
} // namespace Language::Core

namespace Language::Core {

    class Double {
        private:
            Language::Runtime::Owned<double> value;
        public:
            Double() = default;
            Double(double val) : value(val) {}
            static Double Constructor(double val) { return Double(val); }
            double toDouble();
            Language::Runtime::Owned<Language::Core::Double> add(Language::Core::Double& other);
            Language::Runtime::Owned<Language::Core::Double> subtract(Language::Core::Double& other);
            Language::Runtime::Owned<Language::Core::Double> multiply(Language::Core::Double& other);
            Language::Runtime::Owned<Language::Core::Double> divide(Language::Core::Double& other);
            Language::Runtime::Owned<Language::Core::Bool> equals(Language::Core::Double& other);
            Language::Runtime::Owned<Language::Core::Bool> lessThan(Language::Core::Double& other);
            Language::Runtime::Owned<Language::Core::Bool> greaterThan(Language::Core::Double& other);
            Language::Runtime::Owned<Language::Core::Bool> lessOrEqual(Language::Core::Double& other);
            Language::Runtime::Owned<Language::Core::Bool> greaterOrEqual(Language::Core::Double& other);
            Language::Runtime::Owned<Language::Core::Double> negate();
            Language::Runtime::Owned<Language::Core::Double> abs();
            Language::Runtime::Owned<Language::Core::Integer> toInteger();
            Language::Core::Float toFloat();
    };
    
} // namespace Language::Core

namespace Language::Core {

    class String {
        private:
            Language::Runtime::Owned<void*> data;
        public:
            String() = default;
            String(const void* cstr) {
                Language::Runtime::Owned<void*> ptr = Syscall::string_create(cstr);
                Syscall::memcpy(&data, &ptr, 8);
            }
            static String Constructor(const void* cstr) { return String(cstr); }
            const void* toCString();
            Language::Runtime::Owned<Language::Core::Integer> length();
            Language::Runtime::Owned<Language::Core::Bool> isEmpty();
            Language::Runtime::Owned<Language::Core::String> append(Language::Core::String& other);
            Language::Runtime::Owned<Language::Core::String> copy();
            Language::Runtime::Owned<Language::Core::Bool> equals(Language::Core::String& other);
            void dispose();
    };
    
} // namespace Language::Core

// ============================================
// Core Library - Method Implementations
// ============================================

namespace Language::Core {

        int64_t Language::Core::Integer::toInt64() {
        return value;
    }
    Language::Runtime::Owned<Language::Core::Integer> Language::Core::Integer::add(Language::Core::Integer& other) {
        Language::Runtime::Owned<int64_t> v1(value.get());
        Language::Runtime::Owned<int64_t> v2(other.value.get());
        Language::Runtime::Owned<int64_t> result = v1 + v2;
        return Language::Core::Integer(std::move(result));
    }
    Language::Runtime::Owned<Language::Core::Integer> Language::Core::Integer::subtract(Language::Core::Integer& other) {
        Language::Runtime::Owned<int64_t> v1(value.get());
        Language::Runtime::Owned<int64_t> v2(other.value.get());
        Language::Runtime::Owned<int64_t> result = v1 - v2;
        return Language::Core::Integer(std::move(result));
    }
    Language::Runtime::Owned<Language::Core::Integer> Language::Core::Integer::multiply(Language::Core::Integer& other) {
        Language::Runtime::Owned<int64_t> v1(value.get());
        Language::Runtime::Owned<int64_t> v2(other.value.get());
        Language::Runtime::Owned<int64_t> result = v1 * v2;
        return Language::Core::Integer(std::move(result));
    }
    Language::Runtime::Owned<Language::Core::Integer> Language::Core::Integer::divide(Language::Core::Integer& other) {
        Language::Runtime::Owned<int64_t> v1(value.get());
        Language::Runtime::Owned<int64_t> v2(other.value.get());
        Language::Runtime::Owned<int64_t> result = v1 / v2;
        return Language::Core::Integer(std::move(result));
    }
    Language::Runtime::Owned<Language::Core::Integer> Language::Core::Integer::modulo(Language::Core::Integer& other) {
        Language::Runtime::Owned<int64_t> v1(value.get());
        Language::Runtime::Owned<int64_t> v2(other.value.get());
        Language::Runtime::Owned<int64_t> result = v1 % v2;
        return Language::Core::Integer(std::move(result));
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Integer::equals(Language::Core::Integer& other) {
        Language::Runtime::Owned<int64_t> v1(value.get());
        Language::Runtime::Owned<int64_t> v2(other.value.get());
        if (v1 == v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Integer::lessThan(Language::Core::Integer& other) {
        Language::Runtime::Owned<int64_t> v1(value.get());
        Language::Runtime::Owned<int64_t> v2(other.value.get());
        if (v1 < v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Integer::greaterThan(Language::Core::Integer& other) {
        Language::Runtime::Owned<int64_t> v1(value.get());
        Language::Runtime::Owned<int64_t> v2(other.value.get());
        if (v1 > v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Integer::lessOrEqual(Language::Core::Integer& other) {
        Language::Runtime::Owned<int64_t> v1(value.get());
        Language::Runtime::Owned<int64_t> v2(other.value.get());
        if (v1 <= v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Integer::greaterOrEqual(Language::Core::Integer& other) {
        Language::Runtime::Owned<int64_t> v1(value.get());
        Language::Runtime::Owned<int64_t> v2(other.value.get());
        if (v1 >= v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Integer> Language::Core::Integer::negate() {
        Language::Runtime::Owned<int64_t> v(value.get());
        Language::Runtime::Owned<int64_t> result = 0 - v;
        return Language::Core::Integer(std::move(result));
    }
    Language::Runtime::Owned<Language::Core::Integer> Language::Core::Integer::abs() {
        Language::Runtime::Owned<int64_t> v(value.get());
        if (v < 0) {
            Language::Runtime::Owned<int64_t> result = 0 - v;
            return Language::Core::Integer(std::move(result));
        }
        return Language::Core::Integer(std::move(v));
    }
    Language::Runtime::Owned<Language::Core::String> Language::Core::Integer::toString() {
        Language::Runtime::Owned<int64_t> v(value.get());
        Language::Runtime::Owned<const void*> str = Syscall::int_to_string(std::move(v));
        return Language::Core::String(std::move(str));
    }
} // namespace Language::Core

namespace Language::Core {

        bool Language::Core::Bool::toBool() {
        return value;
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Bool::and_(Language::Core::Bool& other) {
        Language::Runtime::Owned<bool> v1(value.get());
        Language::Runtime::Owned<bool> v2(other.value.get());
        Language::Runtime::Owned<bool> result = v1 && v2;
        return Language::Core::Bool(std::move(result));
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Bool::or_(Language::Core::Bool& other) {
        Language::Runtime::Owned<bool> v1(value.get());
        Language::Runtime::Owned<bool> v2(other.value.get());
        Language::Runtime::Owned<bool> result = v1 || v2;
        return Language::Core::Bool(std::move(result));
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Bool::not_() {
        Language::Runtime::Owned<bool> v(value.get());
        Language::Runtime::Owned<bool> result = !v;
        return Language::Core::Bool(std::move(result));
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Bool::xor_(Language::Core::Bool& other) {
        Language::Runtime::Owned<bool> v1(value.get());
        Language::Runtime::Owned<bool> v2(other.value.get());
        if (v1 == v2) {
            return Language::Core::Bool(false);
        }
        return Language::Core::Bool(true);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Bool::equals(Language::Core::Bool& other) {
        Language::Runtime::Owned<bool> v1(value.get());
        Language::Runtime::Owned<bool> v2(other.value.get());
        if (v1 == v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Integer> Language::Core::Bool::toInteger() {
        Language::Runtime::Owned<bool> v(value.get());
        if (v == true) {
            return Language::Core::Integer(1);
        }
        return Language::Core::Integer(0);
    }
} // namespace Language::Core

namespace Language::Core {

        float Language::Core::Float::toFloat() {
        return value;
    }
    Language::Runtime::Owned<Language::Core::Float> Language::Core::Float::add(Language::Core::Float& other) {
        Language::Runtime::Owned<float> v1(value.get());
        Language::Runtime::Owned<float> v2(other.value.get());
        Language::Runtime::Owned<float> result = v1 + v2;
        return Language::Core::Float(std::move(result));
    }
    Language::Runtime::Owned<Language::Core::Float> Language::Core::Float::subtract(Language::Core::Float& other) {
        Language::Runtime::Owned<float> v1(value.get());
        Language::Runtime::Owned<float> v2(other.value.get());
        Language::Runtime::Owned<float> result = v1 - v2;
        return Language::Core::Float(std::move(result));
    }
    Language::Runtime::Owned<Language::Core::Float> Language::Core::Float::multiply(Language::Core::Float& other) {
        Language::Runtime::Owned<float> v1(value.get());
        Language::Runtime::Owned<float> v2(other.value.get());
        Language::Runtime::Owned<float> result = v1 * v2;
        return Language::Core::Float(std::move(result));
    }
    Language::Runtime::Owned<Language::Core::Float> Language::Core::Float::divide(Language::Core::Float& other) {
        Language::Runtime::Owned<float> v1(value.get());
        Language::Runtime::Owned<float> v2(other.value.get());
        Language::Runtime::Owned<float> result = v1 / v2;
        return Language::Core::Float(std::move(result));
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Float::equals(Language::Core::Float& other) {
        Language::Runtime::Owned<float> v1(value.get());
        Language::Runtime::Owned<float> v2(other.value.get());
        if (v1 == v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Float::lessThan(Language::Core::Float& other) {
        Language::Runtime::Owned<float> v1(value.get());
        Language::Runtime::Owned<float> v2(other.value.get());
        if (v1 < v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Float::greaterThan(Language::Core::Float& other) {
        Language::Runtime::Owned<float> v1(value.get());
        Language::Runtime::Owned<float> v2(other.value.get());
        if (v1 > v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Float> Language::Core::Float::negate() {
        Language::Runtime::Owned<float> v(value.get());
        Language::Runtime::Owned<float> zero = 0;
        Language::Runtime::Owned<float> result = zero - v;
        return Language::Core::Float(std::move(result));
    }
    Language::Runtime::Owned<Language::Core::Float> Language::Core::Float::abs() {
        Language::Runtime::Owned<float> v(value.get());
        Language::Runtime::Owned<float> zero = 0;
        if (v < zero) {
            Language::Runtime::Owned<float> result = zero - v;
            return Language::Core::Float(std::move(result));
        }
        return Language::Core::Float(std::move(v));
    }
    Language::Runtime::Owned<Language::Core::Integer> Language::Core::Float::toInteger() {
        Language::Runtime::Owned<float> v(value.get());
        Language::Runtime::Owned<int64_t> result(v.get());
        return Language::Core::Integer(std::move(result));
    }
    Language::Core::Double Language::Core::Float::toDouble() {
        Language::Runtime::Owned<float> v(value.get());
        Language::Runtime::Owned<double> result(v.get());
        return Language::Core::Double(std::move(result));
    }
} // namespace Language::Core

namespace Language::Core {

        double Language::Core::Double::toDouble() {
        return value;
    }
    Language::Runtime::Owned<Language::Core::Double> Language::Core::Double::add(Language::Core::Double& other) {
        Language::Runtime::Owned<double> v1(value.get());
        Language::Runtime::Owned<double> v2(other.value.get());
        Language::Runtime::Owned<double> result = v1 + v2;
        return Language::Core::Double(std::move(result));
    }
    Language::Runtime::Owned<Language::Core::Double> Language::Core::Double::subtract(Language::Core::Double& other) {
        Language::Runtime::Owned<double> v1(value.get());
        Language::Runtime::Owned<double> v2(other.value.get());
        Language::Runtime::Owned<double> result = v1 - v2;
        return Language::Core::Double(std::move(result));
    }
    Language::Runtime::Owned<Language::Core::Double> Language::Core::Double::multiply(Language::Core::Double& other) {
        Language::Runtime::Owned<double> v1(value.get());
        Language::Runtime::Owned<double> v2(other.value.get());
        Language::Runtime::Owned<double> result = v1 * v2;
        return Language::Core::Double(std::move(result));
    }
    Language::Runtime::Owned<Language::Core::Double> Language::Core::Double::divide(Language::Core::Double& other) {
        Language::Runtime::Owned<double> v1(value.get());
        Language::Runtime::Owned<double> v2(other.value.get());
        Language::Runtime::Owned<double> result = v1 / v2;
        return Language::Core::Double(std::move(result));
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Double::equals(Language::Core::Double& other) {
        Language::Runtime::Owned<double> v1(value.get());
        Language::Runtime::Owned<double> v2(other.value.get());
        if (v1 == v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Double::lessThan(Language::Core::Double& other) {
        Language::Runtime::Owned<double> v1(value.get());
        Language::Runtime::Owned<double> v2(other.value.get());
        if (v1 < v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Double::greaterThan(Language::Core::Double& other) {
        Language::Runtime::Owned<double> v1(value.get());
        Language::Runtime::Owned<double> v2(other.value.get());
        if (v1 > v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Double::lessOrEqual(Language::Core::Double& other) {
        Language::Runtime::Owned<double> v1(value.get());
        Language::Runtime::Owned<double> v2(other.value.get());
        if (v1 <= v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::Double::greaterOrEqual(Language::Core::Double& other) {
        Language::Runtime::Owned<double> v1(value.get());
        Language::Runtime::Owned<double> v2(other.value.get());
        if (v1 >= v2) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::Double> Language::Core::Double::negate() {
        Language::Runtime::Owned<double> v(value.get());
        Language::Runtime::Owned<double> zero = 0;
        Language::Runtime::Owned<double> result = zero - v;
        return Language::Core::Double(std::move(result));
    }
    Language::Runtime::Owned<Language::Core::Double> Language::Core::Double::abs() {
        Language::Runtime::Owned<double> v(value.get());
        Language::Runtime::Owned<double> zero = 0;
        if (v < zero) {
            Language::Runtime::Owned<double> result = zero - v;
            return Language::Core::Double(std::move(result));
        }
        return Language::Core::Double(std::move(v));
    }
    Language::Runtime::Owned<Language::Core::Integer> Language::Core::Double::toInteger() {
        Language::Runtime::Owned<double> v(value.get());
        Language::Runtime::Owned<int64_t> result(v.get());
        return Language::Core::Integer(std::move(result));
    }
    Language::Core::Float Language::Core::Double::toFloat() {
        Language::Runtime::Owned<double> v(value.get());
        Language::Runtime::Owned<float> result(v.get());
        return Language::Core::Float(std::move(result));
    }
} // namespace Language::Core

namespace Language::Core {

        const void* Language::Core::String::toCString() {
        Language::Runtime::Owned<void*> ptr(data.get());
        return Syscall::string_cstr(std::move(ptr));
    }
    Language::Runtime::Owned<Language::Core::Integer> Language::Core::String::length() {
        Language::Runtime::Owned<void*> ptr(data.get());
        Language::Runtime::Owned<int64_t> len = Syscall::string_length(std::move(ptr));
        return Language::Core::Integer(std::move(len));
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::String::isEmpty() {
        Language::Runtime::Owned<void*> ptr(data.get());
        Language::Runtime::Owned<int64_t> len = Syscall::string_length(std::move(ptr));
        if (len == 0) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    Language::Runtime::Owned<Language::Core::String> Language::Core::String::append(Language::Core::String& other) {
        Language::Runtime::Owned<void*> ptr1(data.get());
        Language::Runtime::Owned<void*> ptr2(other.data.get());
        Language::Runtime::Owned<void*> newPtr = Syscall::string_concat(std::move(ptr1), std::move(ptr2));
        Syscall::memcpy(&data, &newPtr, 8);
        return std::move(*this);
    }
    Language::Runtime::Owned<Language::Core::String> Language::Core::String::copy() {
        Language::Runtime::Owned<const void*> empty = "";
        Language::Runtime::Owned<Language::Core::String> result = Language::Core::String(std::move(empty));
        Language::Runtime::Owned<void*> ptr(data.get());
        Language::Runtime::Owned<void*> newPtr = Syscall::string_copy(std::move(ptr));
        Syscall::memcpy(&result->data, &newPtr, 8);
        return std::move(result);
    }
    Language::Runtime::Owned<Language::Core::Bool> Language::Core::String::equals(Language::Core::String& other) {
        Language::Runtime::Owned<void*> ptr1(data.get());
        Language::Runtime::Owned<void*> ptr2(other.data.get());
        Language::Runtime::Owned<int64_t> result = Syscall::string_equals(std::move(ptr1), std::move(ptr2));
        if (result == 1) {
            return Language::Core::Bool(true);
        }
        return Language::Core::Bool(false);
    }
    void Language::Core::String::dispose() {
        Language::Runtime::Owned<void*> ptr(data.get());
        if (ptr != 0) {
            Syscall::string_destroy(std::move(ptr));
            Language::Runtime::Owned<void*> zero = 0;
            Syscall::memcpy(&data, &zero, 8);
        }
    }
} // namespace Language::Core

// ============================================
// System::Console Implementation (C++ intrinsic)
// ============================================
namespace System {
class Console {
public:
    // Print without newline - takes Owned<String> by rvalue reference
    static void print(Language::Runtime::Owned<Language::Core::String>&& str) {
        const char* cstr = (const char*)str.get().toCString();
        std::cout << cstr;
        std::cout.flush();
    }

    // Print with newline - takes Owned<String> by rvalue reference
    static void printLine(Language::Runtime::Owned<Language::Core::String>&& str) {
        const char* cstr = (const char*)str.get().toCString();
        std::cout << cstr << std::endl;
    }

    // Read a line from stdin - returns wrapped String
    static Language::Runtime::Owned<Language::Core::String> readLine() {
        std::string* line = new std::string();
        std::getline(std::cin, *line);
        return Language::Core::String((void*)line);
    }

    // Read a single character - returns wrapped String
    static Language::Runtime::Owned<Language::Core::String> readChar() {
        std::string* ch = new std::string();
        char c;
        if (std::cin.get(c)) {
            *ch = c;
        }
        return Language::Core::String((void*)ch);
    }

    // Read an integer - returns wrapped Integer
    static Language::Runtime::Owned<Language::Core::Integer> readInt() {
        int64_t value = 0;
        std::cin >> value;
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        return Language::Core::Integer(value);
    }

    // Read a float - returns wrapped Float
    static Language::Runtime::Owned<Language::Core::Float> readFloat() {
        float value = 0.0f;
        std::cin >> value;
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        return Language::Core::Float(value);
    }

    // Read a double - returns wrapped Double
    static Language::Runtime::Owned<Language::Core::Double> readDouble() {
        double value = 0.0;
        std::cin >> value;
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        return Language::Core::Double(value);
    }

    // Read a boolean - reads 'true'/'false' or '1'/'0', returns wrapped Bool
    static Language::Runtime::Owned<Language::Core::Bool> readBool() {
        std::string input;
        std::cin >> input;
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        // Convert to lowercase for comparison
        for (auto& c : input) c = std::tolower(c);
        bool result = (input == "true" || input == "1" || input == "yes");
        return Language::Core::Bool(result);
    }
};
} // namespace System

// ============================================
// Language::Core::Mem Implementation
// ============================================
namespace Language {
namespace Core {
namespace Mem {

    // Move operation - transfers ownership from Owned<T>
    template<typename T>
    Language::Runtime::Owned<T> move(Language::Runtime::Owned<T>& owned) {
        T extracted = owned.extract();
        return Language::Runtime::Owned<T>(std::move(extracted));
    }

} // namespace Mem
} // namespace Core
} // namespace Language

// ============================================
// Module: __main__
// ============================================
// Import: System
int main() {
    using namespace Language::Core;
    
    System::Console::readInt();
}



